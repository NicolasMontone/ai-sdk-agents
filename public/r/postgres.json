{
  "author": "https://nicolasmontone.com",
  "name": "postgres",
  "type": "registry:lib",
  "description": "PostgreSQL database integration tools for database operations and management. Includes functionality for querying, data manipulation, and database administration tasks.",
  "dependencies": [
    "zod",
    "ai",
    "pg"
  ],
  "devDependencies": [
    "@types/pg"
  ],
  "files": [
    {
      "path": "lib/tools/postgres.ts",
      "type": "registry:lib",
      "content": "import { type Tool, tool } from 'ai'\nimport { z } from 'zod'\nimport { Client as PGClient } from 'pg'\n\ntype PGTools = 'getPublicTablesWithColumns' | 'getExplainForQuery' | 'runQuery'\n\nexport const postgresTools = (\n  { connectionString }: { connectionString: string },\n  config?: {\n    excludeTools?: PGTools[]\n  }\n): Partial<Record<PGTools, Tool>> => {\n  const tools: Partial<Record<PGTools, Tool>> = {\n    getPublicTablesWithColumns: tool({\n      description: 'Get all public tables with columns',\n      parameters: z.object({}),\n      execute: async () => {\n        const tables = await getPublicTablesWithColumns(connectionString)\n        return tables\n      },\n    }),\n    getExplainForQuery: tool({\n      description:\n        \"Analyzes and optimizes a given SQL query, providing a detailed execution plan in JSON format. If the query is not valid, it should return an error message. The function itself will add the EXPLAIN keyword to the query, so you don't need to include it.\",\n      parameters: z.object({\n        query: z.string().describe('The SQL query to analyze'),\n      }),\n      execute: async ({ query }) => {\n        const explain = await getExplainForQuery(query, connectionString)\n        return explain\n      },\n    }),\n    runQuery: tool({\n      description: 'Run a SQL query and return the result',\n      parameters: z.object({\n        query: z.string().describe('The SQL query to run'),\n      }),\n      execute: async ({ query }) => {\n        const result = await runQuery(query, connectionString)\n        return result\n      },\n    }),\n  }\n\n  for (const toolName in tools) {\n    if (config?.excludeTools?.includes(toolName as PGTools)) {\n      delete tools[toolName as PGTools]\n    }\n  }\n\n  return tools\n}\n\nasync function getPublicTablesWithColumns(connectionString: string) {\n  const client = new PGClient(connectionString)\n  await client.connect()\n\n  try {\n    // Get tables\n    const tablesRes = await client.query(`\n        SELECT table_name, table_schema\n        FROM information_schema.tables\n        WHERE table_schema NOT IN ('pg_catalog', 'information_schema')\n        ORDER BY table_schema, table_name\n      `)\n\n    // Get columns for each table\n    const tablesWithColumns = await Promise.all(\n      tablesRes.rows.map(async (table) => {\n        const columnsRes = await client.query(\n          `\n          SELECT column_name, data_type, is_nullable\n          FROM information_schema.columns\n          WHERE table_schema = $1 AND table_name = $2\n          ORDER BY ordinal_position\n        `,\n          [table.table_schema, table.table_name]\n        )\n\n        return {\n          tableName: table.table_name,\n          schemaName: table.table_schema,\n          columns: columnsRes.rows.map((col) => ({\n            name: col.column_name,\n            type: col.data_type,\n            isNullable: col.is_nullable === 'YES',\n          })),\n        }\n      })\n    )\n\n    await client.end()\n\n    return tablesWithColumns\n  } catch (error) {\n    console.error('Error fetching tables with columns:', error)\n    await client.end()\n    return `Error fetching tables with columns: ${error}`\n  }\n}\n\nasync function getExplainForQuery(query: string, connectionString: string) {\n  const explainAnalyzeRegex = /explain\\s+analyze\\s+(.*)/i\n  const explainRegex = /explain\\s+(.*)/i\n\n  let queryToRun = query\n\n  const match =\n    queryToRun.match(explainAnalyzeRegex) || queryToRun.match(explainRegex)\n\n  if (match) {\n    // Remove EXPLAIN or EXPLAIN ANALYZE\n    queryToRun = match[1].trim()\n  }\n\n  const client = new PGClient(connectionString)\n\n  try {\n    await client.connect()\n\n    const explain = await client.query(`EXPLAIN (FORMAT JSON) ${queryToRun}`)\n    await client.end()\n\n    return explain.rows[0]['QUERY PLAN']\n  } catch (error) {\n    console.error('Error running EXPLAIN:', error)\n    await client.end()\n    return `Error running EXPLAIN: ${error}`\n  }\n}\n\nasync function runQuery(query: string, connectionString: string) {\n  const client = new PGClient(connectionString)\n  try {\n    await client.connect()\n    const result = await client.query(query)\n\n    return result.rows\n  } catch (error) {\n    console.error('Error running query:', error)\n\n    return `Error running query: ${error}`\n  } finally {\n    await client.end()\n  }\n}\n",
      "target": ""
    }
  ]
}