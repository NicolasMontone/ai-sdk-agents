{
  "author": "https://nicolasmontone.com",
  "name": "slack",
  "type": "registry:lib",
  "description": "Slack workspace integration tools for messaging and channel management. Features include sending messages, managing threads, channel operations, and workspace administration with full Slack markdown support.",
  "dependencies": [
    "zod",
    "ai",
    "@slack/web-api"
  ],
  "files": [
    {
      "path": "lib/tools/slack.ts",
      "type": "registry:lib",
      "content": "import { tool, type Tool } from 'ai'\nimport { z } from 'zod'\nimport { WebClient } from '@slack/web-api'\n\ntype SlackTools =\n  | 'sendMessage'\n  | 'sendThreadReply'\n  | 'getChannelHistory'\n  | 'getThreadReplies'\n  | 'listChannels'\n  | 'createChannel'\n  | 'inviteToChannel'\n  | 'setChannelTopic'\n\ninterface SlackMessage {\n  ts: string\n  text: string\n  user: string\n  thread_ts?: string\n  reply_count?: number\n}\n\ninterface SlackChannel {\n  id: string\n  name: string\n  topic?: { value: string }\n  purpose?: { value: string }\n  is_private: boolean\n  num_members: number\n}\n\nexport const slackTools = (\n  { token }: { token: string },\n  config?: {\n    excludeTools?: SlackTools[]\n  }\n): Partial<Record<SlackTools, Tool>> => {\n  const client = new WebClient(token)\n\n  const tools: Partial<Record<SlackTools, Tool>> = {\n    sendMessage: tool({\n      description: 'Send a message to a Slack channel or user',\n      parameters: z.object({\n        channel: z\n          .string()\n          .describe('Channel ID or name to send the message to'),\n        text: z\n          .string()\n          .describe(\n            'The message text to send, supports Slack markdown formatting'\n          ),\n        thread_ts: z\n          .string()\n          .optional()\n          .describe('Timestamp of the parent message to reply in a thread'),\n      }),\n      execute: async ({ channel, text, thread_ts }) => {\n        return sendMessage(client, { channel, text, thread_ts })\n      },\n    }),\n\n    sendThreadReply: tool({\n      description: 'Send a reply message in a specific thread',\n      parameters: z.object({\n        channel: z.string().describe('Channel ID where the thread is located'),\n        thread_ts: z\n          .string()\n          .describe('Timestamp of the parent message to reply to'),\n        text: z\n          .string()\n          .describe(\n            'The reply text to send, supports Slack markdown formatting'\n          ),\n      }),\n      execute: async ({ channel, thread_ts, text }) => {\n        return sendMessage(client, { channel, text, thread_ts })\n      },\n    }),\n\n    getChannelHistory: tool({\n      description: 'Get message history from a Slack channel',\n      parameters: z.object({\n        channel: z.string().describe('Channel ID to fetch history from'),\n        limit: z\n          .number()\n          .optional()\n          .describe('Number of messages to return (default: 100, max: 1000)'),\n        oldest: z\n          .string()\n          .optional()\n          .describe('Start of time range (timestamp) to include messages from'),\n        latest: z\n          .string()\n          .optional()\n          .describe('End of time range (timestamp) to include messages from'),\n      }),\n      execute: async ({ channel, limit, oldest, latest }) => {\n        return getChannelHistory(client, { channel, limit, oldest, latest })\n      },\n    }),\n\n    getThreadReplies: tool({\n      description: 'Get all replies in a specific thread',\n      parameters: z.object({\n        channel: z.string().describe('Channel ID where the thread is located'),\n        thread_ts: z\n          .string()\n          .describe('Timestamp of the parent message to get replies for'),\n        limit: z\n          .number()\n          .optional()\n          .describe('Number of replies to return (default: 100, max: 1000)'),\n      }),\n      execute: async ({ channel, thread_ts, limit }) => {\n        return getThreadReplies(client, { channel, thread_ts, limit })\n      },\n    }),\n\n    listChannels: tool({\n      description: 'List all channels in the workspace',\n      parameters: z.object({\n        exclude_archived: z\n          .boolean()\n          .optional()\n          .describe('Exclude archived channels from the list'),\n        types: z\n          .array(z.enum(['public_channel', 'private_channel']))\n          .optional()\n          .describe('Types of channels to include'),\n      }),\n      execute: async ({ exclude_archived, types }) => {\n        return listChannels(client, { exclude_archived, types })\n      },\n    }),\n\n    createChannel: tool({\n      description: 'Create a new Slack channel',\n      parameters: z.object({\n        name: z\n          .string()\n          .describe(\n            'Name of the channel (lowercase letters, numbers, hyphens only)'\n          ),\n        is_private: z\n          .boolean()\n          .optional()\n          .describe('Create a private channel instead of a public one'),\n        topic: z.string().optional().describe('Set the channel topic'),\n      }),\n      execute: async ({ name, is_private, topic }) => {\n        return createChannel(client, { name, is_private, topic })\n      },\n    }),\n\n    inviteToChannel: tool({\n      description: 'Invite users to a channel',\n      parameters: z.object({\n        channel: z.string().describe('Channel ID to invite users to'),\n        users: z\n          .array(z.string())\n          .describe('List of user IDs to invite to the channel'),\n      }),\n      execute: async ({ channel, users }) => {\n        return inviteToChannel(client, { channel, users })\n      },\n    }),\n\n    setChannelTopic: tool({\n      description: 'Set or update a channel topic',\n      parameters: z.object({\n        channel: z.string().describe('Channel ID to set the topic for'),\n        topic: z.string().describe('New topic text for the channel'),\n      }),\n      execute: async ({ channel, topic }) => {\n        return setChannelTopic(client, { channel, topic })\n      },\n    }),\n  }\n\n  for (const toolName in tools) {\n    if (config?.excludeTools?.includes(toolName as SlackTools)) {\n      delete tools[toolName as SlackTools]\n    }\n  }\n\n  return tools\n}\n\nasync function sendMessage(\n  client: WebClient,\n  {\n    channel,\n    text,\n    thread_ts,\n  }: { channel: string; text: string; thread_ts?: string }\n) {\n  try {\n    const result = await client.chat.postMessage({\n      channel,\n      text,\n      thread_ts,\n    })\n    return { ok: result.ok, ts: result.ts, channel: result.channel }\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function getChannelHistory(\n  client: WebClient,\n  {\n    channel,\n    limit = 100,\n    oldest,\n    latest,\n  }: {\n    channel: string\n    limit?: number\n    oldest?: string\n    latest?: string\n  }\n) {\n  try {\n    const result = await client.conversations.history({\n      channel,\n      limit,\n      oldest,\n      latest,\n    })\n    return {\n      ok: result.ok,\n      messages: result.messages as SlackMessage[],\n    }\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function getThreadReplies(\n  client: WebClient,\n  {\n    channel,\n    thread_ts,\n    limit = 100,\n  }: {\n    channel: string\n    thread_ts: string\n    limit?: number\n  }\n) {\n  try {\n    const result = await client.conversations.replies({\n      channel,\n      ts: thread_ts,\n      limit,\n    })\n    return {\n      ok: result.ok,\n      messages: result.messages as SlackMessage[],\n    }\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function listChannels(\n  client: WebClient,\n  {\n    exclude_archived = true,\n    types = ['public_channel'],\n  }: {\n    exclude_archived?: boolean\n    types?: ('public_channel' | 'private_channel')[]\n  }\n) {\n  try {\n    const result = await client.conversations.list({\n      exclude_archived,\n      types: types.join(','),\n    })\n    return {\n      ok: result.ok,\n      channels: result.channels as SlackChannel[],\n    }\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function createChannel(\n  client: WebClient,\n  {\n    name,\n    is_private = false,\n    topic,\n  }: {\n    name: string\n    is_private?: boolean\n    topic?: string\n  }\n) {\n  try {\n    const result = await client.conversations.create({\n      name,\n      is_private,\n    })\n\n    if (topic && result.ok && result.channel?.id) {\n      await client.conversations.setTopic({\n        channel: result.channel.id,\n        topic,\n      })\n    }\n\n    return { ok: result.ok, channel: result.channel as SlackChannel }\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function inviteToChannel(\n  client: WebClient,\n  { channel, users }: { channel: string; users: string[] }\n) {\n  try {\n    const result = await client.conversations.invite({\n      channel,\n      users: users.join(','),\n    })\n    return { ok: result.ok, channel: result.channel }\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function setChannelTopic(\n  client: WebClient,\n  { channel, topic }: { channel: string; topic: string }\n) {\n  try {\n    const result = await client.conversations.setTopic({\n      channel,\n      topic,\n    })\n    return { ok: result.ok, topic }\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n",
      "target": ""
    }
  ]
}