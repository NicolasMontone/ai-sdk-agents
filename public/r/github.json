{
  "author": "https://nicolasmontone.com",
  "name": "github",
  "type": "registry:lib",
  "description": "Comprehensive GitHub API tools for repository management, issue tracking, and pull request handling. Features include repository operations, issue management, PR reviews, and detailed repository analytics.",
  "dependencies": [
    "zod",
    "ai",
    "@octokit/rest"
  ],
  "files": [
    {
      "path": "lib/tools/github.ts",
      "type": "registry:lib",
      "content": "import { tool, type Tool } from 'ai'\nimport { z } from 'zod'\nimport { Octokit } from '@octokit/rest'\n\ntype GithubTools =\n  | 'searchRepositories'\n  | 'listRepositories'\n  | 'getRepository'\n  | 'listPullRequests'\n  | 'getPullRequest'\n  | 'getPullRequestChanges'\n  | 'createIssue'\n  | 'createRepository'\n  | 'getRepositoryLanguages'\n  | 'listIssues'\n  | 'getIssue'\n  | 'commentOnIssue'\n  | 'closeIssue'\n  | 'reopenIssue'\n  | 'assignIssue'\n  | 'labelIssue'\n  | 'listIssueComments'\n  | 'editIssue'\n\nexport const githubTools = (\n  { token, baseUrl }: { token: string; baseUrl?: string },\n  config?: {\n    excludeTools?: GithubTools[]\n  }\n): Partial<Record<GithubTools, Tool>> => {\n  const octokit = new Octokit({\n    auth: token,\n    ...(baseUrl && { baseUrl }),\n  })\n\n  const tools: Partial<Record<GithubTools, Tool>> = {\n    searchRepositories: tool({\n      description: 'Search for GitHub repositories using keywords, with options to sort and filter results',\n      parameters: z.object({\n        query: z.string().describe('Search keywords to find repositories. Can include qualifiers like language:typescript or stars:>1000'),\n        sort: z\n          .enum(['stars', 'forks', 'help-wanted-issues', 'updated'])\n          .optional()\n          .describe('How to sort the results: by number of stars, forks, help-wanted issues, or last updated date'),\n        order: z\n          .enum(['asc', 'desc'])\n          .optional()\n          .describe('Sort order: ascending (lowest to highest) or descending (highest to lowest)'),\n        perPage: z.number().optional().describe('Number of repositories to return per page (max: 100)'),\n      }),\n      execute: async ({\n        query,\n        sort = 'stars',\n        order = 'desc',\n        perPage = 5,\n      }) => {\n        return searchRepositories(octokit, { query, sort, order, perPage })\n      },\n    }),\n    listRepositories: tool({\n      description: 'List all repositories that the authenticated user has access to, including personal, organization, and private repositories',\n      parameters: z.object({}),\n      execute: async () => {\n        return listRepositories(octokit)\n      },\n    }),\n    createRepository: tool({\n      description: 'Create a new GitHub repository in your personal account or in an organization',\n      parameters: z.object({\n        name: z.string().describe('Repository name - must be unique within your account or the target organization'),\n        private: z\n          .boolean()\n          .optional()\n          .describe('Set to true to create a private repository, false for public. Defaults to false'),\n        description: z\n          .string()\n          .optional()\n          .describe('A short description of the repository purpose and contents'),\n        autoInit: z\n          .boolean()\n          .optional()\n          .describe('Set to true to initialize with a README.md file. Useful for immediate cloning'),\n        organization: z\n          .string()\n          .optional()\n          .describe('Organization name where to create the repository. If not provided, creates in personal account'),\n      }),\n      execute: async ({\n        name,\n        private: isPrivate,\n        description,\n        autoInit,\n        organization,\n      }) => {\n        return createRepository(octokit, {\n          name,\n          private: isPrivate,\n          description,\n          autoInit,\n          organization,\n        })\n      },\n    }),\n    getRepository: tool({\n      description: 'Get detailed information about a specific GitHub repository, including stats and metadata',\n      parameters: z.object({\n        repoName: z\n          .string()\n          .describe('Full repository name in the format \"owner/repo\" (e.g., \"microsoft/typescript\")'),\n      }),\n      execute: async ({ repoName }) => {\n        return getRepository(octokit, repoName)\n      },\n    }),\n    getRepositoryLanguages: tool({\n      description: 'Get a breakdown of programming languages used in a repository and their relative proportions',\n      parameters: z.object({\n        repoName: z\n          .string()\n          .describe('Full repository name in the format \"owner/repo\" (e.g., \"microsoft/typescript\")'),\n      }),\n      execute: async ({ repoName }) => {\n        return getRepositoryLanguages(octokit, repoName)\n      },\n    }),\n    listPullRequests: tool({\n      description: 'List pull requests in a repository with filtering options for their current state',\n      parameters: z.object({\n        repoName: z\n          .string()\n          .describe('Full repository name in the format \"owner/repo\" (e.g., \"microsoft/typescript\")'),\n        state: z\n          .enum(['open', 'closed', 'all'])\n          .optional()\n          .describe('Filter PRs by state: open (pending), closed (merged/rejected), or all states'),\n      }),\n      execute: async ({ repoName, state = 'open' }) => {\n        return listPullRequests(octokit, repoName, state)\n      },\n    }),\n    getPullRequest: tool({\n      description: 'Get detailed information about a specific pull request, including its status, changes, and review state',\n      parameters: z.object({\n        repoName: z\n          .string()\n          .describe('Full repository name in the format \"owner/repo\" (e.g., \"microsoft/typescript\")'),\n        prNumber: z.number().describe('The pull request number (not ID) as shown in the PR URL'),\n      }),\n      execute: async ({ repoName, prNumber }) => {\n        return getPullRequest(octokit, repoName, prNumber)\n      },\n    }),\n    getPullRequestChanges: tool({\n      description: 'Get a detailed list of files modified, added, or deleted in a pull request',\n      parameters: z.object({\n        repoName: z\n          .string()\n          .describe('Full repository name in the format \"owner/repo\" (e.g., \"microsoft/typescript\")'),\n        prNumber: z.number().describe('The pull request number (not ID) as shown in the PR URL'),\n      }),\n      execute: async ({ repoName, prNumber }) => {\n        return getPullRequestChanges(octokit, repoName, prNumber)\n      },\n    }),\n    createIssue: tool({\n      description: 'Create a new issue in a repository to track bugs, enhancements, or other tasks',\n      parameters: z.object({\n        repoName: z\n          .string()\n          .describe('Full repository name in the format \"owner/repo\" (e.g., \"microsoft/typescript\")'),\n        title: z.string().describe('Concise summary of the issue - appears in issue lists and notifications'),\n        body: z.string().optional().describe('Detailed description of the issue in GitHub Markdown format'),\n      }),\n      execute: async ({ repoName, title, body }) => {\n        return createIssue(octokit, repoName, title, body)\n      },\n    }),\n    listIssues: tool({\n      description: 'List issues in a repository with filtering options, excluding pull requests',\n      parameters: z.object({\n        repoName: z\n          .string()\n          .describe('Full repository name in the format \"owner/repo\" (e.g., \"microsoft/typescript\")'),\n        state: z\n          .enum(['open', 'closed', 'all'])\n          .optional()\n          .describe('Filter issues by state: open (active), closed (resolved), or all states'),\n      }),\n      execute: async ({ repoName, state = 'open' }) => {\n        return listIssues(octokit, repoName, state)\n      },\n    }),\n    getIssue: tool({\n      description: 'Get detailed information about a specific issue, including its status, assignees, and labels',\n      parameters: z.object({\n        repoName: z\n          .string()\n          .describe('Full repository name in the format \"owner/repo\" (e.g., \"microsoft/typescript\")'),\n        issueNumber: z.number().describe('The issue number (not ID) as shown in the issue URL'),\n      }),\n      execute: async ({ repoName, issueNumber }) => {\n        return getIssue(octokit, repoName, issueNumber)\n      },\n    }),\n    commentOnIssue: tool({\n      description: 'Add a new comment to an existing issue to provide feedback or updates',\n      parameters: z.object({\n        repoName: z\n          .string()\n          .describe('Full repository name in the format \"owner/repo\" (e.g., \"microsoft/typescript\")'),\n        issueNumber: z.number().describe('The issue number (not ID) as shown in the issue URL'),\n        body: z.string().describe('Comment text in GitHub Markdown format - can include formatting, links, and mentions'),\n      }),\n      execute: async ({ repoName, issueNumber, body }) => {\n        return commentOnIssue(octokit, repoName, issueNumber, body)\n      },\n    }),\n    closeIssue: tool({\n      description: 'Close an open issue to indicate it has been resolved or is no longer relevant',\n      parameters: z.object({\n        repoName: z\n          .string()\n          .describe('Full repository name in the format \"owner/repo\" (e.g., \"microsoft/typescript\")'),\n        issueNumber: z.number().describe('The issue number (not ID) as shown in the issue URL'),\n      }),\n      execute: async ({ repoName, issueNumber }) => {\n        return closeIssue(octokit, repoName, issueNumber)\n      },\n    }),\n    reopenIssue: tool({\n      description: 'Reopen a previously closed issue if the problem reoccurs or needs further discussion',\n      parameters: z.object({\n        repoName: z\n          .string()\n          .describe('Full repository name in the format \"owner/repo\" (e.g., \"microsoft/typescript\")'),\n        issueNumber: z.number().describe('The issue number (not ID) as shown in the issue URL'),\n      }),\n      execute: async ({ repoName, issueNumber }) => {\n        return reopenIssue(octokit, repoName, issueNumber)\n      },\n    }),\n    assignIssue: tool({\n      description: 'Assign one or more users to an issue to indicate who is responsible for addressing it',\n      parameters: z.object({\n        repoName: z\n          .string()\n          .describe('Full repository name in the format \"owner/repo\" (e.g., \"microsoft/typescript\")'),\n        issueNumber: z.number().describe('The issue number (not ID) as shown in the issue URL'),\n        assignees: z.array(z.string()).describe('GitHub usernames of people to assign to the issue (must have repository access)'),\n      }),\n      execute: async ({ repoName, issueNumber, assignees }) => {\n        return assignIssue(octokit, repoName, issueNumber, assignees)\n      },\n    }),\n    labelIssue: tool({\n      description: 'Add classification labels to an issue for better organization and filtering',\n      parameters: z.object({\n        repoName: z\n          .string()\n          .describe('Full repository name in the format \"owner/repo\" (e.g., \"microsoft/typescript\")'),\n        issueNumber: z.number().describe('The issue number (not ID) as shown in the issue URL'),\n        labels: z.array(z.string()).describe('Names of labels to apply - must already exist in the repository'),\n      }),\n      execute: async ({ repoName, issueNumber, labels }) => {\n        return labelIssue(octokit, repoName, issueNumber, labels)\n      },\n    }),\n    listIssueComments: tool({\n      description: 'Get all comments on an issue in chronological order to view the discussion history',\n      parameters: z.object({\n        repoName: z\n          .string()\n          .describe('Full repository name in the format \"owner/repo\" (e.g., \"microsoft/typescript\")'),\n        issueNumber: z.number().describe('The issue number (not ID) as shown in the issue URL'),\n      }),\n      execute: async ({ repoName, issueNumber }) => {\n        return listIssueComments(octokit, repoName, issueNumber)\n      },\n    }),\n    editIssue: tool({\n      description: 'Modify an existing issue to update its title or description content',\n      parameters: z.object({\n        repoName: z\n          .string()\n          .describe('Full repository name in the format \"owner/repo\" (e.g., \"microsoft/typescript\")'),\n        issueNumber: z.number().describe('The issue number (not ID) as shown in the issue URL'),\n        title: z.string().optional().describe('New title for the issue - should be clear and concise'),\n        body: z\n          .string()\n          .optional()\n          .describe('New description content in GitHub Markdown format - can include formatting, links, and mentions'),\n      }),\n      execute: async ({ repoName, issueNumber, title, body }) => {\n        return editIssue(octokit, repoName, issueNumber, title, body)\n      },\n    }),\n  }\n\n  for (const toolName in tools) {\n    if (config?.excludeTools?.includes(toolName as GithubTools)) {\n      delete tools[toolName as GithubTools]\n    }\n  }\n\n  return tools\n}\n\nasync function searchRepositories(\n  octokit: Octokit,\n  {\n    query,\n    sort,\n    order,\n    perPage,\n  }: { query: string; sort: 'stars' | 'forks' | 'help-wanted-issues' | 'updated'; order: 'asc' | 'desc'; perPage: number }\n) {\n  try {\n    const { data } = await octokit.rest.search.repos({\n      q: query,\n      sort: sort as 'stars' | 'forks' | 'help-wanted-issues' | 'updated' | undefined,\n      order: order as 'asc' | 'desc',\n      per_page: perPage,\n    })\n\n    return data.items.map((repo) => ({\n      fullName: repo.full_name,\n      description: repo.description,\n      url: repo.html_url,\n      stars: repo.stargazers_count,\n      forks: repo.forks_count,\n      language: repo.language,\n    }))\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function listRepositories(octokit: Octokit) {\n  try {\n    const { data } = await octokit.rest.repos.listForAuthenticatedUser()\n    return data.map((repo) => repo.full_name)\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function createRepository(\n  octokit: Octokit,\n  {\n    name,\n    private: isPrivate,\n    description,\n    autoInit,\n    organization,\n  }: {\n    name: string\n    private?: boolean\n    description?: string\n    autoInit?: boolean\n    organization?: string\n  }\n) {\n  try {\n    const params = {\n      name,\n      private: isPrivate,\n      description,\n      auto_init: autoInit,\n    }\n\n    const { data } = organization\n      ? await octokit.rest.repos.createInOrg({ ...params, org: organization })\n      : await octokit.rest.repos.createForAuthenticatedUser(params)\n\n    return {\n      name: data.full_name,\n      url: data.html_url,\n      private: data.private,\n      description: data.description,\n    }\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function getRepository(octokit: Octokit, repoName: string) {\n  try {\n    const [owner, repo] = repoName.split('/')\n    const { data } = await octokit.rest.repos.get({ owner, repo })\n\n    return {\n      name: data.full_name,\n      description: data.description,\n      url: data.html_url,\n      stars: data.stargazers_count,\n      forks: data.forks_count,\n      openIssues: data.open_issues_count,\n      language: data.language,\n      license: data.license?.name,\n      defaultBranch: data.default_branch,\n    }\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function getRepositoryLanguages(octokit: Octokit, repoName: string) {\n  try {\n    const [owner, repo] = repoName.split('/')\n    const { data } = await octokit.rest.repos.listLanguages({ owner, repo })\n    return data\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function listPullRequests(\n  octokit: Octokit,\n  repoName: string,\n  state: string\n) {\n  try {\n    const [owner, repo] = repoName.split('/')\n    const { data } = await octokit.rest.pulls.list({\n      owner,\n      repo,\n      state: state as 'open' | 'closed' | 'all',\n    })\n\n    return data.map((pr) => ({\n      number: pr.number,\n      title: pr.title,\n      user: pr.user?.login,\n      createdAt: pr.created_at,\n      state: pr.state,\n      url: pr.html_url,\n    }))\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function getPullRequest(\n  octokit: Octokit,\n  repoName: string,\n  prNumber: number\n) {\n  try {\n    const [owner, repo] = repoName.split('/')\n    const { data } = await octokit.rest.pulls.get({\n      owner,\n      repo,\n      pull_number: prNumber,\n    })\n\n    return {\n      number: data.number,\n      title: data.title,\n      user: data.user?.login,\n      body: data.body,\n      createdAt: data.created_at,\n      updatedAt: data.updated_at,\n      state: data.state,\n      merged: data.merged,\n      mergeable: data.mergeable,\n      url: data.html_url,\n    }\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function getPullRequestChanges(\n  octokit: Octokit,\n  repoName: string,\n  prNumber: number\n) {\n  try {\n    const [owner, repo] = repoName.split('/')\n    const { data } = await octokit.rest.pulls.listFiles({\n      owner,\n      repo,\n      pull_number: prNumber,\n    })\n\n    return data.map((file) => ({\n      filename: file.filename,\n      status: file.status,\n      additions: file.additions,\n      deletions: file.deletions,\n      changes: file.changes,\n      rawUrl: file.raw_url,\n      blobUrl: file.blob_url,\n      patch: file.patch,\n    }))\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function createIssue(\n  octokit: Octokit,\n  repoName: string,\n  title: string,\n  body?: string\n) {\n  try {\n    const [owner, repo] = repoName.split('/')\n    const { data } = await octokit.rest.issues.create({\n      owner,\n      repo,\n      title,\n      body,\n    })\n\n    return {\n      id: data.id,\n      number: data.number,\n      title: data.title,\n      body: data.body,\n      url: data.html_url,\n      state: data.state,\n      createdAt: data.created_at,\n      user: data.user?.login,\n    }\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function listIssues(octokit: Octokit, repoName: string, state: string) {\n  try {\n    const [owner, repo] = repoName.split('/')\n    const { data } = await octokit.rest.issues.listForRepo({\n      owner,\n      repo,\n      state: state as 'open' | 'closed' | 'all',\n    })\n\n    return data\n      .filter((issue) => !issue.pull_request) // Filter out pull requests\n      .map((issue) => ({\n        number: issue.number,\n        title: issue.title,\n        user: issue.user?.login,\n        createdAt: issue.created_at,\n        state: issue.state,\n        url: issue.html_url,\n      }))\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function getIssue(\n  octokit: Octokit,\n  repoName: string,\n  issueNumber: number\n) {\n  try {\n    const [owner, repo] = repoName.split('/')\n    const { data } = await octokit.rest.issues.get({\n      owner,\n      repo,\n      issue_number: issueNumber,\n    })\n\n    return {\n      number: data.number,\n      title: data.title,\n      body: data.body,\n      user: data.user?.login,\n      state: data.state,\n      createdAt: data.created_at,\n      updatedAt: data.updated_at,\n      url: data.html_url,\n      assignees: data.assignees?.map((assignee) => assignee.login),\n      labels: data.labels?.map((label) => {\n        // Handle both string labels and label objects\n        return typeof label === 'string' ? label : label.name\n      }),\n    }\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function commentOnIssue(\n  octokit: Octokit,\n  repoName: string,\n  issueNumber: number,\n  body: string\n) {\n  try {\n    const [owner, repo] = repoName.split('/')\n    const { data } = await octokit.rest.issues.createComment({\n      owner,\n      repo,\n      issue_number: issueNumber,\n      body,\n    })\n\n    return {\n      id: data.id,\n      body: data.body,\n      user: data.user?.login,\n      createdAt: data.created_at,\n      url: data.html_url,\n    }\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function closeIssue(\n  octokit: Octokit,\n  repoName: string,\n  issueNumber: number\n) {\n  try {\n    const [owner, repo] = repoName.split('/')\n    await octokit.rest.issues.update({\n      owner,\n      repo,\n      issue_number: issueNumber,\n      state: 'closed',\n    })\n    return { message: `Issue #${issueNumber} closed.` }\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function reopenIssue(\n  octokit: Octokit,\n  repoName: string,\n  issueNumber: number\n) {\n  try {\n    const [owner, repo] = repoName.split('/')\n    await octokit.rest.issues.update({\n      owner,\n      repo,\n      issue_number: issueNumber,\n      state: 'open',\n    })\n    return { message: `Issue #${issueNumber} reopened.` }\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function assignIssue(\n  octokit: Octokit,\n  repoName: string,\n  issueNumber: number,\n  assignees: string[]\n) {\n  try {\n    const [owner, repo] = repoName.split('/')\n    await octokit.rest.issues.addAssignees({\n      owner,\n      repo,\n      issue_number: issueNumber,\n      assignees,\n    })\n    return {\n      message: `Issue #${issueNumber} assigned to ${assignees.join(', ')}.`,\n    }\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function labelIssue(\n  octokit: Octokit,\n  repoName: string,\n  issueNumber: number,\n  labels: string[]\n) {\n  try {\n    const [owner, repo] = repoName.split('/')\n    await octokit.rest.issues.setLabels({\n      owner,\n      repo,\n      issue_number: issueNumber,\n      labels,\n    })\n    return {\n      message: `Labels ${labels.join(', ')} added to issue #${issueNumber}.`,\n    }\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function listIssueComments(\n  octokit: Octokit,\n  repoName: string,\n  issueNumber: number\n) {\n  try {\n    const [owner, repo] = repoName.split('/')\n    const { data } = await octokit.rest.issues.listComments({\n      owner,\n      repo,\n      issue_number: issueNumber,\n    })\n\n    return data.map((comment) => ({\n      id: comment.id,\n      user: comment.user?.login,\n      body: comment.body,\n      createdAt: comment.created_at,\n      url: comment.html_url,\n    }))\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function editIssue(\n  octokit: Octokit,\n  repoName: string,\n  issueNumber: number,\n  title?: string,\n  body?: string\n) {\n  try {\n    const [owner, repo] = repoName.split('/')\n    await octokit.rest.issues.update({\n      owner,\n      repo,\n      issue_number: issueNumber,\n      ...(title && { title }),\n      ...(body && { body }),\n    })\n    return { message: `Issue #${issueNumber} updated.` }\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n",
      "target": ""
    }
  ]
}