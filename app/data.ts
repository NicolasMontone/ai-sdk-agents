export const tools = {
  "discord": {
    "author": "https://nicolasmontone.com",
    "name": "discord",
    "type": "registry:lib",
    "description": "Discord integration tools for sending messages, managing channels, and handling message history. Includes features for sending messages, retrieving channel history, managing channels, and message operations with full Discord markdown support.",
    "dependencies": [
      "zod",
      "ai"
    ],
    "files": [
      {
        "path": "lib/tools/discord.ts",
        "type": "registry:lib",
        "content": "import { tool, type Tool } from 'ai'\nimport { z } from 'zod'\n\ntype DiscordTools =\n  | 'sendMessage'\n  | 'getChannelInfo'\n  | 'listChannels'\n  | 'getChannelMessages'\n  | 'deleteMessage'\n\ninterface DiscordResponse {\n  data?: unknown\n  error?: string\n}\n\n/**\n * Make a request to Discord API.\n * @param url The full URL to make the request to\n * @param options Request options including method, headers, and body\n * @returns A promise that resolves to a DiscordResponse\n */\nasync function makeRequest(\n  url: string,\n  options: RequestInit\n): Promise<DiscordResponse> {\n  try {\n    const response = await fetch(url, options)\n\n    // Handle non-OK responses\n    if (!response.ok) {\n      let errorMessage: string\n      try {\n        const errorData = await response.json()\n        errorMessage = errorData.message || response.statusText\n      } catch {\n        errorMessage = response.statusText\n      }\n      console.error(`Discord API Error: ${response.status} - ${errorMessage}`)\n      return {\n        error: `Discord API Error: ${response.status} - ${errorMessage}`,\n      }\n    }\n\n    // Handle 204 No Content responses\n    if (response.status === 204) {\n      return { data: {} }\n    }\n\n    // Parse JSON response\n    try {\n      const data = await response.json()\n      return { data }\n    } catch (parseError) {\n      console.error('Error parsing JSON response:', parseError)\n      return { error: 'Error parsing API response' }\n    }\n  } catch (error) {\n    console.error('Network or request error:', error)\n    return { error: String(error) }\n  }\n}\n\n// Individual tool functions\nasync function sendMessage(\n  baseUrl: string,\n  headers: HeadersInit,\n  channelId: string,\n  content: string\n): Promise<DiscordResponse> {\n  const data = { content }\n  return makeRequest(`${baseUrl}/channels/${channelId}/messages`, {\n    method: 'POST',\n    headers,\n    body: JSON.stringify(data),\n  })\n}\n\nasync function getChannelInfo(\n  baseUrl: string,\n  headers: HeadersInit,\n  channelId: string\n): Promise<DiscordResponse> {\n  return makeRequest(`${baseUrl}/channels/${channelId}`, {\n    method: 'GET',\n    headers,\n  })\n}\n\nasync function listChannels(\n  baseUrl: string,\n  headers: HeadersInit,\n  guildId: string\n): Promise<DiscordResponse> {\n  return makeRequest(`${baseUrl}/guilds/${guildId}/channels`, {\n    method: 'GET',\n    headers,\n  })\n}\n\nasync function getChannelMessages(\n  baseUrl: string,\n  headers: HeadersInit,\n  channelId: string,\n  limit = 100\n): Promise<DiscordResponse> {\n  return makeRequest(\n    `${baseUrl}/channels/${channelId}/messages?limit=${limit}`,\n    {\n      method: 'GET',\n      headers,\n    }\n  )\n}\n\nasync function deleteMessage(\n  baseUrl: string,\n  headers: HeadersInit,\n  channelId: string,\n  messageId: string\n): Promise<DiscordResponse> {\n  return makeRequest(`${baseUrl}/channels/${channelId}/messages/${messageId}`, {\n    method: 'DELETE',\n    headers,\n  })\n}\n\n// Main Discord tools factory function\nexport const discordTools = (\n  { token }: { token: string },\n  config?: {\n    excludeTools?: DiscordTools[]\n  }\n): Partial<Record<DiscordTools, Tool>> => {\n  const baseUrl = 'https://discord.com/api/v10'\n  const headers = {\n    Authorization: `Bot ${token}`,\n    'Content-Type': 'application/json',\n  }\n\n  const tools: Partial<Record<DiscordTools, Tool>> = {\n    sendMessage: tool({\n      description: 'Send a message to a Discord channel',\n      parameters: z.object({\n        channelId: z\n          .string()\n          .describe('The ID of the channel to send the message to'),\n        content: z\n          .string()\n          .describe('The message content to send, supports Discord markdown'),\n      }),\n      execute: async ({ channelId, content }) => {\n        const result = await sendMessage(baseUrl, headers, channelId, content)\n        if (result.error) {\n          return `Error sending message: ${result.error}`\n        }\n        return `Message sent successfully to channel ${channelId}`\n      },\n    }),\n\n    getChannelMessages: tool({\n      description: 'Get message history from a Discord channel',\n      parameters: z.object({\n        channelId: z\n          .string()\n          .describe('The ID of the channel to fetch messages from'),\n        limit: z\n          .number()\n          .optional()\n          .describe('Maximum number of messages to retrieve (default: 100)'),\n      }),\n      execute: async ({ channelId, limit }) => {\n        const result = await getChannelMessages(\n          baseUrl,\n          headers,\n          channelId,\n          limit\n        )\n        if (result.error) {\n          return `Error getting messages: ${result.error}`\n        }\n        return JSON.stringify(result.data, null, 2)\n      },\n    }),\n\n    getChannelInfo: tool({\n      description: 'Get information about a Discord channel',\n      parameters: z.object({\n        channelId: z\n          .string()\n          .describe('The ID of the channel to get information about'),\n      }),\n      execute: async ({ channelId }) => {\n        const result = await getChannelInfo(baseUrl, headers, channelId)\n        if (result.error) {\n          return `Error getting channel info: ${result.error}`\n        }\n        return JSON.stringify(result.data, null, 2)\n      },\n    }),\n\n    listChannels: tool({\n      description: 'List all channels in a Discord server (guild)',\n      parameters: z.object({\n        guildId: z\n          .string()\n          .describe('The ID of the server (guild) to list channels from'),\n      }),\n      execute: async ({ guildId }) => {\n        const result = await listChannels(baseUrl, headers, guildId)\n        if (result.error) {\n          return `Error listing channels: ${result.error}`\n        }\n        return JSON.stringify(result.data, null, 2)\n      },\n    }),\n\n    deleteMessage: tool({\n      description: 'Delete a message from a Discord channel',\n      parameters: z.object({\n        channelId: z\n          .string()\n          .describe('The ID of the channel containing the message'),\n        messageId: z.string().describe('The ID of the message to delete'),\n      }),\n      execute: async ({ channelId, messageId }) => {\n        const result = await deleteMessage(\n          baseUrl,\n          headers,\n          channelId,\n          messageId\n        )\n        if (result.error) {\n          return `Error deleting message: ${result.error}`\n        }\n        return `Message ${messageId} deleted successfully from channel ${channelId}`\n      },\n    }),\n  }\n\n  for (const toolName in tools) {\n    if (config?.excludeTools?.includes(toolName as DiscordTools)) {\n      delete tools[toolName as DiscordTools]\n    }\n  }\n\n  return tools\n}\n",
        "target": ""
      }
    ],
    "ui": {
      "beta": false,
      "usage": "import { openai } from '@ai-sdk/openai'\nimport { streamText, convertToCoreMessages } from 'ai'\nimport { discordTools } from '@/lib/tools/discord'\n// Allow streaming responses up to 30 seconds\nexport const maxDuration = 30\n\nexport async function POST(req: Request) {\n  const { messages } = await req.json()\n\n  const token = process.env.DISCORD_BOT_TOKEN\n\n  if (!token) {\n    return new Response('No Discord bot token provided', { status: 400 })\n  }\n\n  const result = await streamText({\n    model: openai('gpt-4o'),\n    messages: convertToCoreMessages(messages),\n    system: `\n    You are a Discord Integration Expert specializing in managing Discord server interactions and communications. Your goal is to help users effectively interact with Discord channels, manage messages, and handle server operations using Discord's API capabilities.\n\n    When handling Discord-related requests, you should:\n\n    1. **Analyze the Request**:\n      - Understand the desired Discord operation\n      - Identify required IDs (channel, guild, message)\n      - Consider permissions and limitations\n      - Note any specific formatting requirements\n\n    2. **Available Discord Operations**:\n\n      Messaging:\n      - sendMessage: Send a message to a channel\n        * Supports Discord markdown\n        * Can include formatted text\n        * Handles special characters\n\n      Channel Management:\n      - getChannelInfo: Get details about a channel\n      - listChannels: List all channels in a server\n        * Returns channel IDs, names, and types\n        * Shows channel hierarchy\n\n      Message History:\n      - getChannelMessages: Retrieve message history\n        * Configurable message limit\n        * Returns message content and metadata\n\n      Message Management:\n      - deleteMessage: Remove a message from a channel\n        * Requires message and channel IDs\n        * Handles permission checks\n\n    3. **Best Practices**:\n\n      Message Formatting:\n      - Use appropriate markdown syntax\n      - Structure messages for readability\n      - Consider message length limits\n      - Format code blocks properly\n\n      Channel Operations:\n      - Verify channel accessibility\n      - Check channel types\n      - Consider channel permissions\n      - Handle rate limits appropriately\n\n      Message Management:\n      - Verify message ownership\n      - Consider message age\n      - Handle bulk operations carefully\n      - Respect Discord's rate limits\n\n    **Example Interactions**:\n\n    *User*: \"Send a welcome message to the general channel\"\n\n    *Assistant*: \"I'll help you send a formatted welcome message:\n\n    1. **Message Configuration**:\n       Channel ID: general-channel-id\n       Content formatting: Using Discord markdown\n\n    Let me send the message:\n\n    \\`\\`\\`\n    👋 **Welcome to Our Server!**\n\n    We're glad to have you here! Here's some helpful information:\n    \n    📚 Check out our rules in <#rules-channel>\n    🎮 Introduce yourself in <#introductions>\n    💬 Chat with others in <#general>\n\n    *Feel free to ask any questions!*\n    \\`\\`\\`\n\n    Would you like to:\n    - Modify the message format?\n    - Send to a different channel?\n    - Add more sections?\n    - Include server-specific information?\"\n\n    *User*: \"Get the last 10 messages from the announcements channel\"\n\n    *Assistant*: \"I'll retrieve the recent announcements:\n\n    1. **Retrieval Parameters**:\n       - Channel: announcements\n       - Limit: 10 messages\n       - Sorting: Most recent first\n\n    Let me fetch the messages:\n\n    [Message history would appear here with:\n     - Timestamp\n     - Author\n     - Content\n     - Attachments/embeds]\n\n    Would you like to:\n    - See more messages?\n    - Filter by date?\n    - Search for specific content?\n    - Export the messages?\"\n\n    **Remember**:\n    - Always verify channel and message IDs\n    - Use appropriate formatting for different message types\n    - Consider Discord's rate limits and permissions\n    - Handle errors gracefully\n    - Maintain proper message organization\n\n    When handling requests, focus on providing clear, well-formatted responses while adhering to Discord's best practices and limitations.`,\n    maxSteps: 10,\n    tools: {\n      ...discordTools({ \n        token,\n        enableMessaging: true,\n        enableHistory: true,\n        enableChannelManagement: true,\n        enableMessageManagement: true\n      }),\n    },\n  })\n\n  return result.toDataStreamResponse()\n} ",
      "title": "Platforms",
      "tools": [
        {
          "title": "sendMessage",
          "description": "Send a message to a Discord channel"
        },
        {
          "title": "getChannelInfo",
          "description": "Get information about a Discord channel"
        },
        {
          "title": "listChannels",
          "description": "List all channels in a Discord server"
        },
        {
          "title": "getChannelMessages",
          "description": "Get messages from a Discord channel"
        },
        {
          "title": "deleteMessage",
          "description": "Delete a message from a Discord channel"
        }
      ]
    }
  },
  "giphy": {
    "author": "https://nicolasmontone.com",
    "name": "giphy",
    "type": "registry:lib",
    "description": "Giphy API integration for searching and retrieving GIFs. Supports content rating filters, pagination, and sorting options for finding the perfect animated GIFs.",
    "dependencies": [
      "zod",
      "ai",
      "@giphy/js-fetch-api"
    ],
    "files": [
      {
        "path": "lib/tools/giphy.ts",
        "type": "registry:lib",
        "content": "import { tool, type Tool } from 'ai'\nimport { z } from 'zod'\nimport { GiphyFetch } from '@giphy/js-fetch-api'\n\ntype GiphyTools = 'search'\n\ntype Rating = 'pg' | 'g' | 'y' | 'pg-13' | 'r'\n/**\n * Sorting options\n */\ntype SortTypes = 'relevant' | 'recent'\n\n/**\n * Make a request to Giphy API using the official SDK\n */\n\nasync function makeRequest(\n  client: GiphyFetch,\n  params: {\n    q: string\n    limit?: number\n    offset?: number\n    rating?: Rating\n    sort?: SortTypes\n  }\n) {\n  try {\n    const result = await client.search(params.q, params)\n    return { data: result.data }\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\n// Individual tool functions\nasync function searchGifs(\n  client: GiphyFetch,\n  query: string,\n  limit = 10,\n  offset = 0,\n  rating?: Rating,\n  sort?: SortTypes\n) {\n  return makeRequest(client, {\n    q: query,\n    limit,\n    offset,\n    rating,\n    sort,\n  })\n}\n\nexport const giphyTools = (\n  { apiKey }: { apiKey: string },\n  config?: {\n    excludeTools?: GiphyTools[]\n  }\n): Partial<Record<GiphyTools, Tool>> => {\n  if (!apiKey) {\n    throw new Error('Giphy API key is required')\n  }\n\n  const client = new GiphyFetch(apiKey)\n  const tools: Partial<Record<GiphyTools, Tool>> = {\n    search: tool({\n      description: 'Search for GIFs using keywords',\n      parameters: z.object({\n        query: z.string().describe('The search query to find GIFs'),\n        limit: z\n          .number()\n          .optional()\n          .describe('Maximum number of GIFs to return (default: 10)'),\n        offset: z\n          .number()\n          .optional()\n          .describe('Starting position of results (default: 0)'),\n        rating: z\n          .enum(['g', 'pg', 'pg-13', 'r'])\n          .optional()\n          .describe('Content rating filter'),\n        sort: z\n          .enum(['relevant', 'recent'])\n          .optional()\n          .describe('Sorting option'),\n      }),\n      execute: async ({ query, limit, offset, rating, sort }) => {\n        const result = await searchGifs(\n          client,\n          query,\n          limit,\n          offset,\n          rating,\n          sort\n        )\n        if (result.error) {\n          return `Error searching GIFs: ${result.error}`\n        }\n        return JSON.stringify(result.data, null, 2)\n      },\n    }),\n  }\n\n  // Remove excluded tools\n  for (const toolName in tools) {\n    if (config?.excludeTools?.includes(toolName as GiphyTools)) {\n      delete tools[toolName as GiphyTools]\n    }\n  }\n\n  return tools\n}\n",
        "target": ""
      }
    ],
    "ui": {
      "beta": false,
      "usage": "import { openai } from '@ai-sdk/openai'\nimport { streamText, convertToCoreMessages } from 'ai'\nimport { giphyTools } from '@/lib/tools/giphy'\n// Allow streaming responses up to 30 seconds\nexport const maxDuration = 30\n\nexport async function POST(req: Request) {\n  const { messages } = await req.json()\n\n  const apiKey = process.env.GIPHY_API_KEY\n\n  const result = await streamText({\n    model: openai('gpt-4o'),\n    messages: convertToCoreMessages(messages),\n    system: `\n    You are a Giphy API expert specializing in finding and recommending the perfect GIFs for any situation. Your goal is to help users search and discover GIFs that best match their needs, taking into account content rating, relevance, and recency.\n\n    When a user asks for GIF recommendations or searches, you should:\n\n    1. **Understand the Request**:\n      - Carefully analyze the user's requirements and context\n      - Consider the intended use case and audience\n      - Note any specific preferences for content rating or style\n\n    2. **Craft Effective Searches**:\n      - Use descriptive and relevant keywords\n      - Apply appropriate content rating filters\n      - Consider sorting options based on user needs\n      - Utilize pagination for broader searches\n\n    3. **Provide Thoughtful Recommendations**:\n      - Explain why certain GIFs might work well\n      - Consider the context and tone\n      - Suggest alternatives with different keywords\n      - Respect content rating requirements\n\n    **Rules and Best Practices**:\n\n    1. **Content Rating Guidelines**:\n      - 'g': Suitable for all ages\n      - 'pg': Mild content, parental guidance suggested\n      - 'pg-13': Some mature content\n      - 'r': Mature content, viewer discretion advised\n\n    2. **Search Optimization**:\n      - Use quotation marks for exact phrases\n      - Try multiple related keywords\n      - Consider both 'relevant' and 'recent' sorting\n      - Use offset parameter for pagination\n\n    3. **Results Handling**:\n      - Always verify the content matches the request\n      - Provide alternative suggestions if needed\n      - Consider the context of use\n\n    **Example Interactions**:\n\n    *User*: \"I need a funny cat GIF for a family-friendly presentation\"\n\n    *Assistant*: \"I'll help you find the perfect family-friendly cat GIF. Let me search with appropriate parameters:\n\n    1. **Search Parameters**:\n      - Keywords: \"funny cat\"\n      - Rating: g (suitable for all ages)\n      - Sort: relevant\n      - Limit: 5 (to get the best matches)\n\n    Here are some great options I found:\n\n    [GIF results would appear here]\n\n    These GIFs are:\n    - Family-friendly (G-rated)\n    - High quality and clear\n    - Perfect for presentations\n    - Featuring amusing cat behavior\n\n    Would you like to:\n    - See more options?\n    - Try different keywords?\n    - Focus on specific cat behaviors?\n    - Look for different animation styles?\"\n\n    *User*: \"Find me trending reaction GIFs\"\n\n    *Assistant*: \"I'll search for popular reaction GIFs:\n\n    1. **Search Parameters**:\n      - Keywords: \"reaction\"\n      - Sort: recent\n      - Rating: pg (balanced for general use)\n      - Limit: 10\n\n    Here are the trending reaction GIFs:\n\n    [GIF results would appear here]\n\n    I've selected these because:\n    - They're recently trending\n    - Versatile for various reactions\n    - Suitable for general audiences\n    - High engagement rates\n\n    Would you like to:\n    - Filter by specific emotions?\n    - See more options?\n    - Adjust the content rating?\n    - Focus on specific categories?\"\n\n    **Remember**:\n    - Always prioritize user requirements\n    - Consider the intended audience\n    - Provide clear explanations for your choices\n    - Offer alternatives when appropriate\n    - Respect content rating guidelines\n\n    When handling requests, maintain a helpful and informative tone while focusing on finding the most appropriate GIFs for the user's needs.`,\n    maxSteps: 10,\n    tools: {\n      ...giphyTools({ apiKey }),\n    },\n  })\n\n  return result.toDataStreamResponse()\n} ",
      "title": "Search",
      "tools": [
        {
          "title": "search",
          "description": "Search for GIFs on Giphy"
        }
      ]
    }
  },
  "github": {
    "author": "https://nicolasmontone.com",
    "name": "github",
    "type": "registry:lib",
    "description": "Comprehensive GitHub API tools for repository management, issue tracking, and pull request handling. Features include repository operations, issue management, PR reviews, and detailed repository analytics.",
    "dependencies": [
      "zod",
      "ai",
      "@octokit/rest"
    ],
    "files": [
      {
        "path": "lib/tools/github.ts",
        "type": "registry:lib",
        "content": "import { tool, type Tool } from 'ai'\nimport { z } from 'zod'\nimport { Octokit } from '@octokit/rest'\n\ntype GithubTools =\n  | 'searchRepositories'\n  | 'listRepositories'\n  | 'getRepository'\n  | 'listPullRequests'\n  | 'getPullRequest'\n  | 'getPullRequestChanges'\n  | 'createIssue'\n  | 'createRepository'\n  | 'getRepositoryLanguages'\n  | 'listIssues'\n  | 'getIssue'\n  | 'commentOnIssue'\n  | 'closeIssue'\n  | 'reopenIssue'\n  | 'assignIssue'\n  | 'labelIssue'\n  | 'listIssueComments'\n  | 'editIssue'\n\nexport const githubTools = (\n  { token, baseUrl }: { token: string; baseUrl?: string },\n  config?: {\n    excludeTools?: GithubTools[]\n  }\n): Partial<Record<GithubTools, Tool>> => {\n  const octokit = new Octokit({\n    auth: token,\n    ...(baseUrl && { baseUrl }),\n  })\n\n  const tools: Partial<Record<GithubTools, Tool>> = {\n    searchRepositories: tool({\n      description: 'Search for GitHub repositories using keywords, with options to sort and filter results',\n      parameters: z.object({\n        query: z.string().describe('Search keywords to find repositories. Can include qualifiers like language:typescript or stars:>1000'),\n        sort: z\n          .enum(['stars', 'forks', 'help-wanted-issues', 'updated'])\n          .optional()\n          .describe('How to sort the results: by number of stars, forks, help-wanted issues, or last updated date'),\n        order: z\n          .enum(['asc', 'desc'])\n          .optional()\n          .describe('Sort order: ascending (lowest to highest) or descending (highest to lowest)'),\n        perPage: z.number().optional().describe('Number of repositories to return per page (max: 100)'),\n      }),\n      execute: async ({\n        query,\n        sort = 'stars',\n        order = 'desc',\n        perPage = 5,\n      }) => {\n        return searchRepositories(octokit, { query, sort, order, perPage })\n      },\n    }),\n    listRepositories: tool({\n      description: 'List all repositories that the authenticated user has access to, including personal, organization, and private repositories',\n      parameters: z.object({}),\n      execute: async () => {\n        return listRepositories(octokit)\n      },\n    }),\n    createRepository: tool({\n      description: 'Create a new GitHub repository in your personal account or in an organization',\n      parameters: z.object({\n        name: z.string().describe('Repository name - must be unique within your account or the target organization'),\n        private: z\n          .boolean()\n          .optional()\n          .describe('Set to true to create a private repository, false for public. Defaults to false'),\n        description: z\n          .string()\n          .optional()\n          .describe('A short description of the repository purpose and contents'),\n        autoInit: z\n          .boolean()\n          .optional()\n          .describe('Set to true to initialize with a README.md file. Useful for immediate cloning'),\n        organization: z\n          .string()\n          .optional()\n          .describe('Organization name where to create the repository. If not provided, creates in personal account'),\n      }),\n      execute: async ({\n        name,\n        private: isPrivate,\n        description,\n        autoInit,\n        organization,\n      }) => {\n        return createRepository(octokit, {\n          name,\n          private: isPrivate,\n          description,\n          autoInit,\n          organization,\n        })\n      },\n    }),\n    getRepository: tool({\n      description: 'Get detailed information about a specific GitHub repository, including stats and metadata',\n      parameters: z.object({\n        repoName: z\n          .string()\n          .describe('Full repository name in the format \"owner/repo\" (e.g., \"microsoft/typescript\")'),\n      }),\n      execute: async ({ repoName }) => {\n        return getRepository(octokit, repoName)\n      },\n    }),\n    getRepositoryLanguages: tool({\n      description: 'Get a breakdown of programming languages used in a repository and their relative proportions',\n      parameters: z.object({\n        repoName: z\n          .string()\n          .describe('Full repository name in the format \"owner/repo\" (e.g., \"microsoft/typescript\")'),\n      }),\n      execute: async ({ repoName }) => {\n        return getRepositoryLanguages(octokit, repoName)\n      },\n    }),\n    listPullRequests: tool({\n      description: 'List pull requests in a repository with filtering options for their current state',\n      parameters: z.object({\n        repoName: z\n          .string()\n          .describe('Full repository name in the format \"owner/repo\" (e.g., \"microsoft/typescript\")'),\n        state: z\n          .enum(['open', 'closed', 'all'])\n          .optional()\n          .describe('Filter PRs by state: open (pending), closed (merged/rejected), or all states'),\n      }),\n      execute: async ({ repoName, state = 'open' }) => {\n        return listPullRequests(octokit, repoName, state)\n      },\n    }),\n    getPullRequest: tool({\n      description: 'Get detailed information about a specific pull request, including its status, changes, and review state',\n      parameters: z.object({\n        repoName: z\n          .string()\n          .describe('Full repository name in the format \"owner/repo\" (e.g., \"microsoft/typescript\")'),\n        prNumber: z.number().describe('The pull request number (not ID) as shown in the PR URL'),\n      }),\n      execute: async ({ repoName, prNumber }) => {\n        return getPullRequest(octokit, repoName, prNumber)\n      },\n    }),\n    getPullRequestChanges: tool({\n      description: 'Get a detailed list of files modified, added, or deleted in a pull request',\n      parameters: z.object({\n        repoName: z\n          .string()\n          .describe('Full repository name in the format \"owner/repo\" (e.g., \"microsoft/typescript\")'),\n        prNumber: z.number().describe('The pull request number (not ID) as shown in the PR URL'),\n      }),\n      execute: async ({ repoName, prNumber }) => {\n        return getPullRequestChanges(octokit, repoName, prNumber)\n      },\n    }),\n    createIssue: tool({\n      description: 'Create a new issue in a repository to track bugs, enhancements, or other tasks',\n      parameters: z.object({\n        repoName: z\n          .string()\n          .describe('Full repository name in the format \"owner/repo\" (e.g., \"microsoft/typescript\")'),\n        title: z.string().describe('Concise summary of the issue - appears in issue lists and notifications'),\n        body: z.string().optional().describe('Detailed description of the issue in GitHub Markdown format'),\n      }),\n      execute: async ({ repoName, title, body }) => {\n        return createIssue(octokit, repoName, title, body)\n      },\n    }),\n    listIssues: tool({\n      description: 'List issues in a repository with filtering options, excluding pull requests',\n      parameters: z.object({\n        repoName: z\n          .string()\n          .describe('Full repository name in the format \"owner/repo\" (e.g., \"microsoft/typescript\")'),\n        state: z\n          .enum(['open', 'closed', 'all'])\n          .optional()\n          .describe('Filter issues by state: open (active), closed (resolved), or all states'),\n      }),\n      execute: async ({ repoName, state = 'open' }) => {\n        return listIssues(octokit, repoName, state)\n      },\n    }),\n    getIssue: tool({\n      description: 'Get detailed information about a specific issue, including its status, assignees, and labels',\n      parameters: z.object({\n        repoName: z\n          .string()\n          .describe('Full repository name in the format \"owner/repo\" (e.g., \"microsoft/typescript\")'),\n        issueNumber: z.number().describe('The issue number (not ID) as shown in the issue URL'),\n      }),\n      execute: async ({ repoName, issueNumber }) => {\n        return getIssue(octokit, repoName, issueNumber)\n      },\n    }),\n    commentOnIssue: tool({\n      description: 'Add a new comment to an existing issue to provide feedback or updates',\n      parameters: z.object({\n        repoName: z\n          .string()\n          .describe('Full repository name in the format \"owner/repo\" (e.g., \"microsoft/typescript\")'),\n        issueNumber: z.number().describe('The issue number (not ID) as shown in the issue URL'),\n        body: z.string().describe('Comment text in GitHub Markdown format - can include formatting, links, and mentions'),\n      }),\n      execute: async ({ repoName, issueNumber, body }) => {\n        return commentOnIssue(octokit, repoName, issueNumber, body)\n      },\n    }),\n    closeIssue: tool({\n      description: 'Close an open issue to indicate it has been resolved or is no longer relevant',\n      parameters: z.object({\n        repoName: z\n          .string()\n          .describe('Full repository name in the format \"owner/repo\" (e.g., \"microsoft/typescript\")'),\n        issueNumber: z.number().describe('The issue number (not ID) as shown in the issue URL'),\n      }),\n      execute: async ({ repoName, issueNumber }) => {\n        return closeIssue(octokit, repoName, issueNumber)\n      },\n    }),\n    reopenIssue: tool({\n      description: 'Reopen a previously closed issue if the problem reoccurs or needs further discussion',\n      parameters: z.object({\n        repoName: z\n          .string()\n          .describe('Full repository name in the format \"owner/repo\" (e.g., \"microsoft/typescript\")'),\n        issueNumber: z.number().describe('The issue number (not ID) as shown in the issue URL'),\n      }),\n      execute: async ({ repoName, issueNumber }) => {\n        return reopenIssue(octokit, repoName, issueNumber)\n      },\n    }),\n    assignIssue: tool({\n      description: 'Assign one or more users to an issue to indicate who is responsible for addressing it',\n      parameters: z.object({\n        repoName: z\n          .string()\n          .describe('Full repository name in the format \"owner/repo\" (e.g., \"microsoft/typescript\")'),\n        issueNumber: z.number().describe('The issue number (not ID) as shown in the issue URL'),\n        assignees: z.array(z.string()).describe('GitHub usernames of people to assign to the issue (must have repository access)'),\n      }),\n      execute: async ({ repoName, issueNumber, assignees }) => {\n        return assignIssue(octokit, repoName, issueNumber, assignees)\n      },\n    }),\n    labelIssue: tool({\n      description: 'Add classification labels to an issue for better organization and filtering',\n      parameters: z.object({\n        repoName: z\n          .string()\n          .describe('Full repository name in the format \"owner/repo\" (e.g., \"microsoft/typescript\")'),\n        issueNumber: z.number().describe('The issue number (not ID) as shown in the issue URL'),\n        labels: z.array(z.string()).describe('Names of labels to apply - must already exist in the repository'),\n      }),\n      execute: async ({ repoName, issueNumber, labels }) => {\n        return labelIssue(octokit, repoName, issueNumber, labels)\n      },\n    }),\n    listIssueComments: tool({\n      description: 'Get all comments on an issue in chronological order to view the discussion history',\n      parameters: z.object({\n        repoName: z\n          .string()\n          .describe('Full repository name in the format \"owner/repo\" (e.g., \"microsoft/typescript\")'),\n        issueNumber: z.number().describe('The issue number (not ID) as shown in the issue URL'),\n      }),\n      execute: async ({ repoName, issueNumber }) => {\n        return listIssueComments(octokit, repoName, issueNumber)\n      },\n    }),\n    editIssue: tool({\n      description: 'Modify an existing issue to update its title or description content',\n      parameters: z.object({\n        repoName: z\n          .string()\n          .describe('Full repository name in the format \"owner/repo\" (e.g., \"microsoft/typescript\")'),\n        issueNumber: z.number().describe('The issue number (not ID) as shown in the issue URL'),\n        title: z.string().optional().describe('New title for the issue - should be clear and concise'),\n        body: z\n          .string()\n          .optional()\n          .describe('New description content in GitHub Markdown format - can include formatting, links, and mentions'),\n      }),\n      execute: async ({ repoName, issueNumber, title, body }) => {\n        return editIssue(octokit, repoName, issueNumber, title, body)\n      },\n    }),\n  }\n\n  for (const toolName in tools) {\n    if (config?.excludeTools?.includes(toolName as GithubTools)) {\n      delete tools[toolName as GithubTools]\n    }\n  }\n\n  return tools\n}\n\nasync function searchRepositories(\n  octokit: Octokit,\n  {\n    query,\n    sort,\n    order,\n    perPage,\n  }: { query: string; sort: 'stars' | 'forks' | 'help-wanted-issues' | 'updated'; order: 'asc' | 'desc'; perPage: number }\n) {\n  try {\n    const { data } = await octokit.rest.search.repos({\n      q: query,\n      sort: sort as 'stars' | 'forks' | 'help-wanted-issues' | 'updated' | undefined,\n      order: order as 'asc' | 'desc',\n      per_page: perPage,\n    })\n\n    return data.items.map((repo) => ({\n      fullName: repo.full_name,\n      description: repo.description,\n      url: repo.html_url,\n      stars: repo.stargazers_count,\n      forks: repo.forks_count,\n      language: repo.language,\n    }))\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function listRepositories(octokit: Octokit) {\n  try {\n    const { data } = await octokit.rest.repos.listForAuthenticatedUser()\n    return data.map((repo) => repo.full_name)\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function createRepository(\n  octokit: Octokit,\n  {\n    name,\n    private: isPrivate,\n    description,\n    autoInit,\n    organization,\n  }: {\n    name: string\n    private?: boolean\n    description?: string\n    autoInit?: boolean\n    organization?: string\n  }\n) {\n  try {\n    const params = {\n      name,\n      private: isPrivate,\n      description,\n      auto_init: autoInit,\n    }\n\n    const { data } = organization\n      ? await octokit.rest.repos.createInOrg({ ...params, org: organization })\n      : await octokit.rest.repos.createForAuthenticatedUser(params)\n\n    return {\n      name: data.full_name,\n      url: data.html_url,\n      private: data.private,\n      description: data.description,\n    }\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function getRepository(octokit: Octokit, repoName: string) {\n  try {\n    const [owner, repo] = repoName.split('/')\n    const { data } = await octokit.rest.repos.get({ owner, repo })\n\n    return {\n      name: data.full_name,\n      description: data.description,\n      url: data.html_url,\n      stars: data.stargazers_count,\n      forks: data.forks_count,\n      openIssues: data.open_issues_count,\n      language: data.language,\n      license: data.license?.name,\n      defaultBranch: data.default_branch,\n    }\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function getRepositoryLanguages(octokit: Octokit, repoName: string) {\n  try {\n    const [owner, repo] = repoName.split('/')\n    const { data } = await octokit.rest.repos.listLanguages({ owner, repo })\n    return data\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function listPullRequests(\n  octokit: Octokit,\n  repoName: string,\n  state: string\n) {\n  try {\n    const [owner, repo] = repoName.split('/')\n    const { data } = await octokit.rest.pulls.list({\n      owner,\n      repo,\n      state: state as 'open' | 'closed' | 'all',\n    })\n\n    return data.map((pr) => ({\n      number: pr.number,\n      title: pr.title,\n      user: pr.user?.login,\n      createdAt: pr.created_at,\n      state: pr.state,\n      url: pr.html_url,\n    }))\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function getPullRequest(\n  octokit: Octokit,\n  repoName: string,\n  prNumber: number\n) {\n  try {\n    const [owner, repo] = repoName.split('/')\n    const { data } = await octokit.rest.pulls.get({\n      owner,\n      repo,\n      pull_number: prNumber,\n    })\n\n    return {\n      number: data.number,\n      title: data.title,\n      user: data.user?.login,\n      body: data.body,\n      createdAt: data.created_at,\n      updatedAt: data.updated_at,\n      state: data.state,\n      merged: data.merged,\n      mergeable: data.mergeable,\n      url: data.html_url,\n    }\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function getPullRequestChanges(\n  octokit: Octokit,\n  repoName: string,\n  prNumber: number\n) {\n  try {\n    const [owner, repo] = repoName.split('/')\n    const { data } = await octokit.rest.pulls.listFiles({\n      owner,\n      repo,\n      pull_number: prNumber,\n    })\n\n    return data.map((file) => ({\n      filename: file.filename,\n      status: file.status,\n      additions: file.additions,\n      deletions: file.deletions,\n      changes: file.changes,\n      rawUrl: file.raw_url,\n      blobUrl: file.blob_url,\n      patch: file.patch,\n    }))\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function createIssue(\n  octokit: Octokit,\n  repoName: string,\n  title: string,\n  body?: string\n) {\n  try {\n    const [owner, repo] = repoName.split('/')\n    const { data } = await octokit.rest.issues.create({\n      owner,\n      repo,\n      title,\n      body,\n    })\n\n    return {\n      id: data.id,\n      number: data.number,\n      title: data.title,\n      body: data.body,\n      url: data.html_url,\n      state: data.state,\n      createdAt: data.created_at,\n      user: data.user?.login,\n    }\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function listIssues(octokit: Octokit, repoName: string, state: string) {\n  try {\n    const [owner, repo] = repoName.split('/')\n    const { data } = await octokit.rest.issues.listForRepo({\n      owner,\n      repo,\n      state: state as 'open' | 'closed' | 'all',\n    })\n\n    return data\n      .filter((issue) => !issue.pull_request) // Filter out pull requests\n      .map((issue) => ({\n        number: issue.number,\n        title: issue.title,\n        user: issue.user?.login,\n        createdAt: issue.created_at,\n        state: issue.state,\n        url: issue.html_url,\n      }))\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function getIssue(\n  octokit: Octokit,\n  repoName: string,\n  issueNumber: number\n) {\n  try {\n    const [owner, repo] = repoName.split('/')\n    const { data } = await octokit.rest.issues.get({\n      owner,\n      repo,\n      issue_number: issueNumber,\n    })\n\n    return {\n      number: data.number,\n      title: data.title,\n      body: data.body,\n      user: data.user?.login,\n      state: data.state,\n      createdAt: data.created_at,\n      updatedAt: data.updated_at,\n      url: data.html_url,\n      assignees: data.assignees?.map((assignee) => assignee.login),\n      labels: data.labels?.map((label) => {\n        // Handle both string labels and label objects\n        return typeof label === 'string' ? label : label.name\n      }),\n    }\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function commentOnIssue(\n  octokit: Octokit,\n  repoName: string,\n  issueNumber: number,\n  body: string\n) {\n  try {\n    const [owner, repo] = repoName.split('/')\n    const { data } = await octokit.rest.issues.createComment({\n      owner,\n      repo,\n      issue_number: issueNumber,\n      body,\n    })\n\n    return {\n      id: data.id,\n      body: data.body,\n      user: data.user?.login,\n      createdAt: data.created_at,\n      url: data.html_url,\n    }\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function closeIssue(\n  octokit: Octokit,\n  repoName: string,\n  issueNumber: number\n) {\n  try {\n    const [owner, repo] = repoName.split('/')\n    await octokit.rest.issues.update({\n      owner,\n      repo,\n      issue_number: issueNumber,\n      state: 'closed',\n    })\n    return { message: `Issue #${issueNumber} closed.` }\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function reopenIssue(\n  octokit: Octokit,\n  repoName: string,\n  issueNumber: number\n) {\n  try {\n    const [owner, repo] = repoName.split('/')\n    await octokit.rest.issues.update({\n      owner,\n      repo,\n      issue_number: issueNumber,\n      state: 'open',\n    })\n    return { message: `Issue #${issueNumber} reopened.` }\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function assignIssue(\n  octokit: Octokit,\n  repoName: string,\n  issueNumber: number,\n  assignees: string[]\n) {\n  try {\n    const [owner, repo] = repoName.split('/')\n    await octokit.rest.issues.addAssignees({\n      owner,\n      repo,\n      issue_number: issueNumber,\n      assignees,\n    })\n    return {\n      message: `Issue #${issueNumber} assigned to ${assignees.join(', ')}.`,\n    }\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function labelIssue(\n  octokit: Octokit,\n  repoName: string,\n  issueNumber: number,\n  labels: string[]\n) {\n  try {\n    const [owner, repo] = repoName.split('/')\n    await octokit.rest.issues.setLabels({\n      owner,\n      repo,\n      issue_number: issueNumber,\n      labels,\n    })\n    return {\n      message: `Labels ${labels.join(', ')} added to issue #${issueNumber}.`,\n    }\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function listIssueComments(\n  octokit: Octokit,\n  repoName: string,\n  issueNumber: number\n) {\n  try {\n    const [owner, repo] = repoName.split('/')\n    const { data } = await octokit.rest.issues.listComments({\n      owner,\n      repo,\n      issue_number: issueNumber,\n    })\n\n    return data.map((comment) => ({\n      id: comment.id,\n      user: comment.user?.login,\n      body: comment.body,\n      createdAt: comment.created_at,\n      url: comment.html_url,\n    }))\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function editIssue(\n  octokit: Octokit,\n  repoName: string,\n  issueNumber: number,\n  title?: string,\n  body?: string\n) {\n  try {\n    const [owner, repo] = repoName.split('/')\n    await octokit.rest.issues.update({\n      owner,\n      repo,\n      issue_number: issueNumber,\n      ...(title && { title }),\n      ...(body && { body }),\n    })\n    return { message: `Issue #${issueNumber} updated.` }\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n",
        "target": ""
      }
    ],
    "ui": {
      "beta": false,
      "usage": "import { openai } from '@ai-sdk/openai'\nimport { streamText, convertToCoreMessages } from 'ai'\nimport { githubTools } from '@/lib/tools/github'\n// Allow streaming responses up to 30 seconds\nexport const maxDuration = 30\n\nexport async function POST(req: Request) {\n  const { messages } = await req.json()\n\n  const githubToken = process.env.GITHUB_TOKEN\n\n  if (!githubToken) {\n    return new Response('No GitHub token provided', { status: 400 })\n  }\n\n  const result = await streamText({\n    model: openai('gpt-4o'),\n    messages: convertToCoreMessages(messages),\n    system: `\n    You are a GitHub expert specializing in repository management, issue tracking, and pull request workflows. Your goal is to help users effectively manage their GitHub repositories and development workflows by providing detailed, data-driven analysis and specific recommendations.\n\n    When users interact with GitHub repositories, you should:\n\n    1. **Repository Management**:\n      - Help users search for repositories based on specific criteria\n      - Assist in creating new repositories with proper initialization\n      - Provide repository statistics and language breakdowns\n      - Guide users through repository settings and configurations\n\n    2. **Issue Management**:\n      - Help create well-structured issues with clear descriptions\n      - Assist in managing issue labels, assignments, and status\n      - Guide users through issue workflows and best practices\n      - Help organize and prioritize issues effectively\n\n    3. **Pull Request Workflows**:\n      - Review pull request details and changes\n      - Analyze PR impact and provide insights\n      - Guide users through PR review processes\n      - Help manage PR statuses and mergeability\n\n    **Rules and Guidelines**:\n\n    1. **Creating Issues**:\n      - Always include clear, descriptive titles\n      - Provide detailed descriptions with steps to reproduce for bugs\n      - Add appropriate labels and assignees when needed\n      - Follow repository-specific issue templates if available\n\n    2. **Managing Pull Requests**:\n      - Review PR changes thoroughly before providing advice\n      - Consider the impact on the codebase\n      - Check for merge conflicts and suggest resolutions\n      - Ensure PR descriptions are complete and informative\n\n    3. **Repository Operations**:\n      - Verify repository access before operations\n      - Follow repository-specific guidelines\n      - Consider visibility settings (public/private)\n      - Include proper initialization options when creating repos\n\n    **Example Interactions**:\n\n    1. **Creating a New Issue**:\n    User: \"I need to create an issue for a bug in the login system\"\n\n    Response: \"I'll help you create a well-structured issue. Based on best practices, here's how we'll format it:\n\n    Title: 'Login System: Authentication fails for users with special characters in email'\n\n    Description:\n    \\`\\`\\`\n    ## Bug Description\n    Users with special characters in their email addresses (e.g., '+' or '.') are unable to log in to the system.\n\n    ## Steps to Reproduce\n    1. Navigate to the login page\n    2. Enter an email containing special characters (e.g., 'test.user+123@example.com')\n    3. Enter the correct password\n    4. Click the login button\n\n    ## Expected Behavior\n    User should be successfully logged in\n\n    ## Actual Behavior\n    System shows authentication error message\n\n    ## Environment\n    - Browser: Chrome 96.0\n    - OS: Windows 10\n    - App Version: 2.1.0\n\n    ## Additional Notes\n    This issue affects approximately 15% of our user base who use email aliases.\n    \\`\\`\\`\n\n    I'll create this issue with appropriate labels like 'bug' and 'high-priority'.\"\n\n    2. **Analyzing a Pull Request**:\n    User: \"Can you check this PR and tell me if it's ready to merge?\"\n\n    Response: \"I've analyzed the pull request and here's what I found:\n\n    1. **Changes Overview**:\n       - Modified files: 5\n       - Lines added: 120\n       - Lines removed: 45\n       - Primary changes in authentication module\n\n    2. **Status Checks**:\n       - CI tests: Passing\n       - Code coverage: 95% (increased by 2%)\n       - No merge conflicts present\n\n    3. **Code Review Findings**:\n       - All required dependencies are properly imported\n       - Unit tests are included for new functionality\n       - Documentation has been updated\n       - Follows project code style guidelines\n\n    4. **Recommendations**:\n       - PR is ready for merge\n       - Suggest squashing commits for cleaner history\n       - Consider adding a changelog entry\n       - Update version number in package.json\n\n    Would you like me to proceed with any of these recommendations?\"\n\n    3. **Repository Analysis**:\n    User: \"How can I improve my repository's contribution workflow?\"\n\n    Response: \"I've analyzed your repository structure and here are my recommendations:\n\n    1. **Documentation Improvements**:\n       - Add a detailed CONTRIBUTING.md file\n       - Update README.md with development setup steps\n       - Include code style guidelines\n       - Add issue and PR templates\n\n    2. **Workflow Optimizations**:\n       - Set up automated CI/CD pipelines\n       - Add status checks for PRs\n       - Configure branch protection rules\n       - Implement automated code review tools\n\n    3. **Community Engagement**:\n       - Add issue labels for better organization\n       - Set up project boards for tracking\n       - Create milestone tracking\n       - Add community health files\n\n    Would you like me to help implement any of these suggestions?\"\n\n    Remember to:\n    - Always verify repository permissions before operations\n    - Provide clear, actionable feedback\n    - Follow repository-specific guidelines\n    - Consider security implications of changes\n    - Maintain professional communication\n    - Use data-driven insights for recommendations\n\n    Your responses should be:\n    - Clear and concise\n    - Well-structured\n    - Action-oriented\n    - Security-conscious\n    - Professional in tone\n    `,\n    maxSteps: 22,\n    tools: {\n      ...githubTools({ token: githubToken }),\n    },\n  })\n\n  return result.toDataStreamResponse()\n} ",
      "title": "Platforms",
      "tools": [
        {
          "title": "searchRepositories",
          "description": "Search for repositories on GitHub"
        },
        {
          "title": "listRepositories",
          "description": "List all repositories on GitHub"
        },
        {
          "title": "getRepository",
          "description": "Get information about a GitHub repository"
        },
        {
          "title": "listPullRequests",
          "description": "List all pull requests on a GitHub repository"
        },
        {
          "title": "getPullRequest",
          "description": "Get information about a GitHub pull request"
        },
        {
          "title": "getPullRequestChanges",
          "description": "Get changes from a GitHub pull request"
        },
        {
          "title": "createIssue",
          "description": "Create an issue on a GitHub repository"
        },
        {
          "title": "reopenIssue",
          "description": "Reopen an issue on a GitHub repository"
        },
        {
          "title": "assignIssue",
          "description": "Assign an issue to a user on a GitHub repository"
        },
        {
          "title": "labelIssue",
          "description": "Label an issue on a GitHub repository"
        },
        {
          "title": "listIssueComments",
          "description": "List all comments on an issue on a GitHub repository"
        },
        {
          "title": "editIssue",
          "description": "Edit an issue on a GitHub repository"
        }
      ]
    }
  },
  "math": {
    "author": "https://nicolasmontone.com",
    "name": "math",
    "type": "registry:lib",
    "description": "Mathematical calculation tools providing essential mathematical operations including trigonometric functions, logarithms, exponentials, and basic arithmetic calculations.",
    "dependencies": [
      "zod",
      "ai"
    ],
    "files": [
      {
        "path": "lib/tools/math.ts",
        "type": "registry:lib",
        "content": "import { tool, type Tool } from 'ai'\nimport { z } from 'zod'\n\ntype CalculatorTools =\n  | 'add'\n  | 'subtract'\n  | 'multiply'\n  | 'divide'\n  | 'exponentiate'\n  | 'factorial'\n  | 'isPrime'\n  | 'squareRoot'\n  | 'sin'\n  | 'cos'\n  | 'tan'\n  | 'sqrt'\n  | 'log'\n  | 'exp'\n\nexport const calculatorTools = (config?: {\n  excludeTools?: CalculatorTools[]\n}): Partial<Record<CalculatorTools, Tool>> => {\n  const tools: Partial<Record<CalculatorTools, Tool>> = {\n    add: tool({\n      description: 'Add two numbers and return the result',\n      parameters: z.object({\n        a: z.number().describe('First number'),\n        b: z.number().describe('Second number'),\n      }),\n      execute: async ({ a, b }) => {\n        return add(a, b)\n      },\n    }),\n    subtract: tool({\n      description: 'Subtract second number from first and return the result',\n      parameters: z.object({\n        a: z.number().describe('First number'),\n        b: z.number().describe('Second number'),\n      }),\n      execute: async ({ a, b }) => {\n        return subtract(a, b)\n      },\n    }),\n    multiply: tool({\n      description: 'Multiply two numbers and return the result',\n      parameters: z.object({\n        a: z.number().describe('First number'),\n        b: z.number().describe('Second number'),\n      }),\n      execute: async ({ a, b }) => {\n        return multiply(a, b)\n      },\n    }),\n    divide: tool({\n      description: 'Divide first number by second and return the result',\n      parameters: z.object({\n        a: z.number().describe('Numerator'),\n        b: z.number().describe('Denominator'),\n      }),\n      execute: async ({ a, b }) => {\n        return divide(a, b)\n      },\n    }),\n    exponentiate: tool({\n      description: 'Raise first number to the power of the second number',\n      parameters: z.object({\n        a: z.number().describe('Base'),\n        b: z.number().describe('Exponent'),\n      }),\n      execute: async ({ a, b }) => {\n        return exponentiate(a, b)\n      },\n    }),\n    factorial: tool({\n      description: 'Calculate the factorial of a number',\n      parameters: z.object({\n        n: z.number().int().describe('Number to calculate the factorial of'),\n      }),\n      execute: async ({ n }) => {\n        return factorial(n)\n      },\n    }),\n    isPrime: tool({\n      description: 'Check if a number is prime',\n      parameters: z.object({\n        n: z.number().int().describe('Number to check if prime'),\n      }),\n      execute: async ({ n }) => {\n        return isPrime(n)\n      },\n    }),\n    squareRoot: tool({\n      description: 'Calculate the square root of a number',\n      parameters: z.object({\n        n: z.number().describe('Number to calculate the square root of'),\n      }),\n      execute: async ({ n }) => {\n        return squareRoot(n)\n      },\n    }),\n    sin: tool({\n      description: 'Calculate the sine of an angle in radians',\n      parameters: z.object({\n        n: z.number().describe('Angle in radians'),\n      }),\n      execute: async ({ n }) => {\n        return sin(n)\n      },\n    }),\n    cos: tool({\n      description: 'Calculate the cosine of an angle in radians',\n      parameters: z.object({\n        n: z.number().describe('Angle in radians'),\n      }),\n      execute: async ({ n }) => {\n        return cos(n)\n      },\n    }),\n    tan: tool({\n      description: 'Calculate the tangent of an angle in radians',\n      parameters: z.object({\n        n: z.number().describe('Angle in radians'),\n      }),\n      execute: async ({ n }) => {\n        return tan(n)\n      },\n    }),\n    sqrt: tool({\n      description: 'Calculate the square root of a number (alias for squareRoot)',\n      parameters: z.object({\n        n: z.number().describe('Number to calculate the square root of'),\n      }),\n      execute: async ({ n }) => {\n        return squareRoot(n)\n      },\n    }),\n    log: tool({\n      description: 'Calculate the natural logarithm (base e) of a number',\n      parameters: z.object({\n        n: z.number().describe('Number to calculate the logarithm of'),\n      }),\n      execute: async ({ n }) => {\n        return log(n)\n      },\n    }),\n    exp: tool({\n      description: 'Calculate e raised to the power of a number',\n      parameters: z.object({\n        n: z.number().describe('Power to raise e to'),\n      }),\n      execute: async ({ n }) => {\n        return exp(n)\n      },\n    }),\n  }\n\n  for (const toolName in tools) {\n    if (config?.excludeTools?.includes(toolName as CalculatorTools)) {\n      delete tools[toolName as CalculatorTools]\n    }\n  }\n\n  return tools\n}\n\nfunction add(a: number, b: number) {\n  return { result: a + b }\n}\n\nfunction subtract(a: number, b: number) {\n  return { result: a - b }\n}\n\nfunction multiply(a: number, b: number) {\n  return { result: a * b }\n}\n\nfunction divide(a: number, b: number) {\n  if (b === 0) {\n    return { error: 'Cannot divide by zero' }\n  }\n  try {\n    return { result: a / b }\n  } catch (error) {\n    return { error }\n  }\n}\n\nfunction exponentiate(a: number, b: number) {\n  return { result: a ** b }\n}\n\nfunction factorial(n: number) {\n  if (n < 0) {\n    return { error: 'Factorial is not defined for negative numbers' }\n  }\n  let result = 1\n  for (let i = 2; i <= n; i++) {\n    result *= i\n  }\n  return { result }\n}\n\nfunction isPrime(n: number) {\n  if (n <= 1) {\n    return { result: false }\n  }\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      return { result: false }\n    }\n  }\n  return { result: true }\n}\n\nfunction squareRoot(n: number) {\n  if (n < 0) {\n    return { error: 'Square Root is not defined for negative numbers' }\n  }\n  return { result: Math.sqrt(n) }\n}\n\nfunction sin(n: number) {\n  return { result: Math.sin(n) }\n}\n\nfunction cos(n: number) {\n  return { result: Math.cos(n) }\n}\n\nfunction tan(n: number) {\n  return { result: Math.tan(n) }\n}\n\nfunction log(n: number) {\n  if (n <= 0) {\n    return { error: 'Logarithm is not defined for non-positive numbers' }\n  }\n  return { result: Math.log(n) }\n}\n\nfunction exp(n: number) {\n  return { result: Math.exp(n) }\n}\n",
        "target": ""
      }
    ],
    "ui": {
      "beta": false,
      "usage": "import { openai } from '@ai-sdk/openai'\nimport { streamText, convertToCoreMessages } from 'ai'\nimport { calculatorTools } from '@/lib/tools/math'\n// Allow streaming responses up to 30 seconds\nexport const maxDuration = 30\n\nexport async function POST(req: Request) {\n  const { messages } = await req.json()\n\n  const result = await streamText({\n    model: openai('gpt-4o'),\n    messages: convertToCoreMessages(messages),\n    system: `\n    You are a Mathematical Operations Expert specializing in precise calculations and mathematical problem-solving. Your goal is to help users perform accurate calculations, understand mathematical concepts, and solve complex mathematical problems using a variety of mathematical functions.\n\n    When handling mathematical queries, you should:\n\n    1. **Analyze the Mathematical Problem**:\n      - Understand the type of calculation needed\n      - Identify the appropriate mathematical operations\n      - Consider the order of operations\n      - Note any special requirements or constraints\n\n    2. **Available Mathematical Operations**:\n\n      Basic Arithmetic:\n      - add: Add two numbers (a + b)\n      - subtract: Subtract second number from first (a - b)\n      - multiply: Multiply two numbers (a × b)\n      - divide: Divide first number by second (a ÷ b)\n\n      Advanced Operations:\n      - exponentiate: Raise a number to a power (a^b)\n      - factorial: Calculate factorial of a number (n!)\n      - isPrime: Check if a number is prime\n      - squareRoot/sqrt: Calculate square root (√n)\n\n      Trigonometric Functions:\n      - sin: Calculate sine of angle in radians\n      - cos: Calculate cosine of angle in radians\n      - tan: Calculate tangent of angle in radians\n\n      Logarithmic and Exponential:\n      - log: Calculate natural logarithm (ln(n))\n      - exp: Calculate e raised to power (e^n)\n\n    3. **Best Practices**:\n\n      Arithmetic Operations:\n      - Verify input numbers are within valid ranges\n      - Consider potential division by zero\n      - Handle negative numbers appropriately\n      - Maintain precision in calculations\n\n      Special Functions:\n      - Ensure inputs are valid (e.g., non-negative for sqrt)\n      - Handle edge cases (e.g., factorial of 0)\n      - Consider domain restrictions\n      - Note when approximations are used\n\n      Trigonometric Calculations:\n      - Confirm angle units (radians)\n      - Consider periodic nature\n      - Handle special angles\n      - Note precision requirements\n\n    **Example Interactions**:\n\n    *User*: \"Calculate the area of a circle with radius 5\"\n\n    *Assistant*: \"I'll help you calculate the area of a circle using the formula A = πr².\n\n    Let's break this down:\n    1. We need to square the radius (5² = 25)\n    2. Then multiply by π (approximately 3.14159)\n\n    Let me perform the calculation:\n\n    1. First, let's calculate 5²:\n       Using exponentiate(5, 2)\n       Result: 25\n\n    2. Now multiply by π:\n       Using multiply(25, 3.14159)\n       Result: 78.53975\n\n    The area of the circle with radius 5 is approximately 78.54 square units.\n\n    Would you like to:\n    - Calculate the circumference?\n    - Try a different radius?\n    - See the step-by-step calculation?\n    - Learn about related circle properties?\"\n\n    *User*: \"Is 17 a prime number?\"\n\n    *Assistant*: \"Let me check if 17 is prime using the isPrime function.\n\n    Using isPrime(17)\n    Result: true\n\n    Yes, 17 is a prime number!\n\n    This means:\n    - 17 has exactly two factors: 1 and itself\n    - It cannot be evenly divided by any number between 1 and 17\n    - It's the 7th prime number (after 2, 3, 5, 7, 11, 13)\n\n    Would you like to:\n    - Check another number?\n    - Find the next prime number?\n    - See the factors of 17?\n    - Learn about prime factorization?\"\n\n    **Remember**:\n    - Always verify input validity\n    - Show intermediate steps for complex calculations\n    - Explain mathematical concepts when relevant\n    - Provide context for results\n    - Suggest related calculations or concepts\n\n    When responding to queries, maintain a clear and educational tone while ensuring precise mathematical accuracy.`,\n    maxSteps: 10,\n    tools: {\n      ...calculatorTools(),\n    },\n  })\n\n  return result.toDataStreamResponse()\n} ",
      "title": "Utils",
      "tools": [
        {
          "title": "add",
          "description": "Add two numbers"
        },
        {
          "title": "subtract",
          "description": "Subtract two numbers"
        },
        {
          "title": "multiply",
          "description": "Multiply two numbers"
        },
        {
          "title": "divide",
          "description": "Divide two numbers"
        },
        {
          "title": "exponentiate",
          "description": "Exponentiate a number"
        },
        {
          "title": "factorial",
          "description": "Calculate the factorial of a number"
        },
        {
          "title": "isPrime",
          "description": "Check if a number is prime"
        },
        {
          "title": "squareRoot",
          "description": "Calculate the square root of a number"
        },
        {
          "title": "sin",
          "description": "Calculate the sine of a number"
        },
        {
          "title": "cos",
          "description": "Calculate the cosine of a number"
        },
        {
          "title": "tan",
          "description": "Calculate the tangent of a number"
        },
        {
          "title": "sqrt",
          "description": "Calculate the square root of a number"
        },
        {
          "title": "log",
          "description": "Calculate the logarithm of a number"
        },
        {
          "title": "exp",
          "description": "Calculate the exponential of a number"
        }
      ]
    }
  },
  "perplexity": {
    "author": "https://nicolasmontone.com",
    "name": "perplexity",
    "type": "registry:lib",
    "description": "Perplexity AI integration for advanced web search and information retrieval. Features customizable model parameters, system prompts, and returns both content and citations for comprehensive results.",
    "dependencies": [
      "zod",
      "ai"
    ],
    "files": [
      {
        "path": "lib/tools/perplexity.ts",
        "type": "registry:lib",
        "content": "import { tool, type Tool } from 'ai'\nimport { z } from 'zod'\n\ntype PerplexityTools = 'search'\n\n/**\n  - sonar-reasoning-pro\t127k\tChat Completion\n  - sonar-reasoning\t127k\tChat Completion\n  - sonar-pro\t200k\tChat Completion\n  - sonar\t127k\tChat Completion\n */\ntype PerplexityModel =\n  | 'sonar-reasoning-pro'\n  | 'sonar-reasoning'\n  | 'sonar-pro'\n  | 'sonar'\n\nasync function getAnswer({\n  query,\n  apiKey,\n  model = 'sonar',\n  maxTokens = 1000,\n  systemPrompt = 'Be precise and concise.',\n  temperature = 0.2,\n  topP = 0.9,\n  frequencyPenalty = 1,\n}: {\n  query: string\n  apiKey: string\n  model?: PerplexityModel\n  maxTokens?: number\n  systemPrompt?: string\n  temperature?: number\n  topP?: number\n  frequencyPenalty?: number\n}) {\n  const response = await fetch('https://api.perplexity.ai/chat/completions', {\n    method: 'POST',\n    headers: {\n      Authorization: `Bearer ${apiKey}`,\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      model,\n      messages: [\n        { role: 'system', content: systemPrompt },\n        { role: 'user', content: query },\n      ],\n      temperature,\n      top_p: topP,\n      frequency_penalty: frequencyPenalty,\n      max_tokens: maxTokens,\n    }),\n  })\n\n  const data = await response.json()\n  return {\n    content: data.choices[0].message.content,\n    citations: data.citations || []\n  }\n}\n\nexport const perplexityTools = (\n  {\n    apiKey,\n    model = 'sonar',\n    maxTokens,\n    systemPrompt,\n    temperature,\n    topP,\n    frequencyPenalty,\n  }: {\n    apiKey: string\n    model?: PerplexityModel\n    maxTokens?: number\n    systemPrompt?: string\n    temperature?: number\n    topP?: number\n    frequencyPenalty?: number\n  },\n  {\n    excludeTools,\n  }: {\n    excludeTools?: PerplexityTools[]\n  } = {}\n): Partial<Record<PerplexityTools, Tool>> => {\n  const tools: Partial<Record<PerplexityTools, Tool>> = {\n    search: tool({\n      description: 'Search the web for information',\n      parameters: z.object({\n        query: z.string().describe('The query to search for'),\n      }),\n      execute: async ({ query }) => {\n        const { content, citations } = await getAnswer({\n          query,\n          apiKey,\n          model,\n          maxTokens,\n          systemPrompt,\n          temperature,\n          topP,\n          frequencyPenalty,\n        })\n        return { content, citations }\n      },\n    }),\n  }\n\n  for (const toolName in tools) {\n    if (excludeTools?.includes(toolName as PerplexityTools)) {\n      delete tools[toolName as PerplexityTools]\n    }\n  }\n\n  return tools\n}\n",
        "target": ""
      }
    ],
    "ui": {
      "beta": false,
      "usage": "import { openai } from '@ai-sdk/openai'\nimport { streamText, convertToCoreMessages } from 'ai'\nimport { perplexityTools } from '@/lib/tools/perplexity'\n// Allow streaming responses up to 30 seconds\nexport const maxDuration = 30\n\nexport async function POST(req: Request) {\n  const { messages } = await req.json()\n\n  const apiKey = process.env.PERPLEXITY_API_KEY\n\n  if (!apiKey) {\n    return new Response('No API key provided', { status: 400 })\n  }\n\n  const result = await streamText({\n    model: openai('gpt-4o'),\n    messages: convertToCoreMessages(messages),\n\n    system: `\n    You are an Academic Research Assistant specializing in comprehensive literature review, scientific inquiry, and academic research synthesis. Your goal is to help researchers navigate scholarly content, analyze scientific papers, and synthesize research findings across various academic disciplines.\n\n    When conducting research, you should:\n\n    1. **Research Methodology**:\n       - Define clear research objectives\n       - Identify key research questions\n       - Establish scope and limitations\n       - Consider interdisciplinary perspectives\n       - Apply systematic review methods\n\n    2. **Literature Search Strategy**:\n       Model Selection Based on Research Phase:\n       \n       For Initial Research Exploration:\n       - Use sonar-pro for broad literature review\n       - Cast a wide net across disciplines\n       - Identify key theories and frameworks\n       - Map the research landscape\n\n       For Detailed Analysis:\n       - Use sonar-reasoning-pro for in-depth paper analysis\n       - Focus on methodology evaluation\n       - Extract key findings and implications\n       - Analyze research gaps\n\n       For Systematic Reviews:\n       - Use sonar-reasoning for structured analysis\n       - Apply inclusion/exclusion criteria\n       - Synthesize findings across studies\n       - Evaluate research quality\n\n    3. **Academic Rigor Guidelines**:\n       - Prioritize peer-reviewed sources\n       - Evaluate research methodology\n       - Assess statistical significance\n       - Consider sample sizes and limitations\n       - Examine research design quality\n       - Check for potential biases\n\n    4. **Research Synthesis Framework**:\n       - Compare methodologies\n       - Identify patterns in findings\n       - Note contradictions in literature\n       - Evaluate strength of evidence\n       - Consider practical implications\n\n    **Example Research Process**:\n\n    *User*: \"Analyze recent research on the role of gut microbiota in neurodegenerative diseases\"\n\n    *Assistant*: \"I'll conduct a systematic research analysis:\n\n    1. **Initial Literature Mapping**:\n       Using sonar-pro for comprehensive coverage:\n       - Recent systematic reviews (last 2 years)\n       - Key meta-analyses\n       - Landmark studies\n       - Emerging research directions\n\n    2. **Methodological Analysis**:\n       Using sonar-reasoning-pro to examine:\n       - Study designs and methods\n       - Sample sizes and populations\n       - Control measures\n       - Statistical approaches\n       - Intervention protocols\n\n    3. **Findings Synthesis**:\n       Key Research Themes:\n       - Microbiota composition patterns\n       - Mechanistic pathways\n       - Clinical implications\n       - Therapeutic potential\n\n    4. **Research Quality Assessment**:\n       - Methodology robustness\n       - Statistical power\n       - Replication status\n       - External validity\n       - Clinical relevance\n\n    The synthesis will include:\n    - Current state of knowledge\n    - Methodological strengths/weaknesses\n    - Research gaps\n    - Future directions\n    - Clinical implications\n    - Research recommendations\n\n    Would you like to:\n    - Focus on specific diseases?\n    - Examine particular mechanisms?\n    - Analyze therapeutic approaches?\n    - Review clinical trials?\"\n\n    **Research Best Practices**:\n    - Follow systematic review protocols\n    - Apply critical appraisal tools\n    - Use standardized quality assessment\n    - Document search methodology\n    - Track citation chains\n    - Consider publication bias\n    - Evaluate replication studies\n\n    Your research output should be:\n    1. Methodologically sound\n    2. Evidence-based\n    3. Critically evaluated\n    4. Properly contextualized\n    5. Clearly synthesized\n    6. Practically applicable\n    7. Future-oriented\n\n    Remember to:\n    - Document search strategies\n    - Note methodological limitations\n    - Consider alternative interpretations\n    - Highlight research gaps\n    - Suggest future research directions\n    - Address practical implications\n    - Maintain academic rigor`,\n    maxSteps: 22,\n    tools: {\n      ...perplexityTools({ \n        apiKey,\n        model: 'sonar-reasoning-pro',\n        temperature: 0.2,\n        topP: 0.9,\n        frequencyPenalty: 1\n      }),\n    },\n  })\n\n  return result.toDataStreamResponse()\n} ",
      "title": "Search",
      "tools": [
        {
          "title": "search",
          "description": "Search for information on Perplexity"
        }
      ]
    }
  },
  "postgres": {
    "author": "https://nicolasmontone.com",
    "name": "postgres",
    "type": "registry:lib",
    "description": "PostgreSQL database integration tools for database operations and management. Includes functionality for querying, data manipulation, and database administration tasks.",
    "dependencies": [
      "zod",
      "ai",
      "pg"
    ],
    "devDependencies": [
      "@types/pg"
    ],
    "files": [
      {
        "path": "lib/tools/postgres.ts",
        "type": "registry:lib",
        "content": "import { type Tool, tool } from 'ai'\nimport { z } from 'zod'\nimport { Client as PGClient } from 'pg'\n\ntype PGTools = 'getPublicTablesWithColumns' | 'getExplainForQuery' | 'runQuery'\n\nexport const postgresTools = (\n  { connectionString }: { connectionString: string },\n  config?: {\n    excludeTools?: PGTools[]\n  }\n): Partial<Record<PGTools, Tool>> => {\n  const tools: Partial<Record<PGTools, Tool>> = {\n    getPublicTablesWithColumns: tool({\n      description: 'Get all public tables with columns',\n      parameters: z.object({}),\n      execute: async () => {\n        const tables = await getPublicTablesWithColumns(connectionString)\n        return tables\n      },\n    }),\n    getExplainForQuery: tool({\n      description:\n        \"Analyzes and optimizes a given SQL query, providing a detailed execution plan in JSON format. If the query is not valid, it should return an error message. The function itself will add the EXPLAIN keyword to the query, so you don't need to include it.\",\n      parameters: z.object({\n        query: z.string().describe('The SQL query to analyze'),\n      }),\n      execute: async ({ query }) => {\n        const explain = await getExplainForQuery(query, connectionString)\n        return explain\n      },\n    }),\n    runQuery: tool({\n      description: 'Run a SQL query and return the result',\n      parameters: z.object({\n        query: z.string().describe('The SQL query to run'),\n      }),\n      execute: async ({ query }) => {\n        const result = await runQuery(query, connectionString)\n        return result\n      },\n    }),\n  }\n\n  for (const toolName in tools) {\n    if (config?.excludeTools?.includes(toolName as PGTools)) {\n      delete tools[toolName as PGTools]\n    }\n  }\n\n  return tools\n}\n\nasync function getPublicTablesWithColumns(connectionString: string) {\n  const client = new PGClient(connectionString)\n  await client.connect()\n\n  try {\n    // Get tables\n    const tablesRes = await client.query(`\n        SELECT table_name, table_schema\n        FROM information_schema.tables\n        WHERE table_schema NOT IN ('pg_catalog', 'information_schema')\n        ORDER BY table_schema, table_name\n      `)\n\n    // Get columns for each table\n    const tablesWithColumns = await Promise.all(\n      tablesRes.rows.map(async (table) => {\n        const columnsRes = await client.query(\n          `\n          SELECT column_name, data_type, is_nullable\n          FROM information_schema.columns\n          WHERE table_schema = $1 AND table_name = $2\n          ORDER BY ordinal_position\n        `,\n          [table.table_schema, table.table_name]\n        )\n\n        return {\n          tableName: table.table_name,\n          schemaName: table.table_schema,\n          columns: columnsRes.rows.map((col) => ({\n            name: col.column_name,\n            type: col.data_type,\n            isNullable: col.is_nullable === 'YES',\n          })),\n        }\n      })\n    )\n\n    await client.end()\n\n    return tablesWithColumns\n  } catch (error) {\n    console.error('Error fetching tables with columns:', error)\n    await client.end()\n    return `Error fetching tables with columns: ${error}`\n  }\n}\n\nasync function getExplainForQuery(query: string, connectionString: string) {\n  const explainAnalyzeRegex = /explain\\s+analyze\\s+(.*)/i\n  const explainRegex = /explain\\s+(.*)/i\n\n  let queryToRun = query\n\n  const match =\n    queryToRun.match(explainAnalyzeRegex) || queryToRun.match(explainRegex)\n\n  if (match) {\n    // Remove EXPLAIN or EXPLAIN ANALYZE\n    queryToRun = match[1].trim()\n  }\n\n  const client = new PGClient(connectionString)\n\n  try {\n    await client.connect()\n\n    const explain = await client.query(`EXPLAIN (FORMAT JSON) ${queryToRun}`)\n    await client.end()\n\n    return explain.rows[0]['QUERY PLAN']\n  } catch (error) {\n    console.error('Error running EXPLAIN:', error)\n    await client.end()\n    return `Error running EXPLAIN: ${error}`\n  }\n}\n\nasync function runQuery(query: string, connectionString: string) {\n  const client = new PGClient(connectionString)\n  try {\n    await client.connect()\n    const result = await client.query(query)\n\n    return result.rows\n  } catch (error) {\n    console.error('Error running query:', error)\n\n    return `Error running query: ${error}`\n  } finally {\n    await client.end()\n  }\n}\n",
        "target": ""
      }
    ],
    "ui": {
      "beta": false,
      "usage": "import { openai } from '@ai-sdk/openai'\nimport { streamText, convertToCoreMessages } from 'ai'\nimport { postgresTools } from '@/lib/tools/postgres'\n// Allow streaming responses up to 30 seconds\nexport const maxDuration = 30\n\nexport async function POST(req: Request) {\n  const { messages } = await req.json()\n\n  const connectionString = process.env.DATABASE_URL\n\n  if (!connectionString) {\n    return new Response('No connection string provided', { status: 400 })\n  }\n\n  const result = await streamText({\n    model: openai('gpt-4o'),\n    messages: convertToCoreMessages(messages),\n    system: `\n    You are a PostgreSQL database optimization expert specializing in query performance tuning. Your goal is to help users improve the performance of their SQL queries by providing detailed, data-driven analysis and specific recommendations based on their actual database schema and data.\n    When a user provides a SQL query and asks for optimization advice, you should:\n\n    1. **Understand the Query**: Read the SQL query carefully to grasp its purpose and logic, do not assume anything.\n\n    2. **Gather Information Using Tools**:\n      - Use **getPublicTablesWithColumns** to understand table structures and data types.\n      - Use **getIndexes** to check existing indexes on the involved tables.\n      - Use **getExplainForQuery** to obtain the execution plan of the query.\n      - Use **getTableStats** to get information on table sizes and row counts.\n      - Use **getForeignKeyConstraints** to understand relationships between tables.\n\n    3. **Analyze the Execution Plan**:\n      - Identify any slow operations like sequential scans, nested loops, or hash joins.\n      - Note which parts of the query are the most resource-intensive.\n\n    4. **Identify Specific Bottlenecks**:\n      - Determine if missing indexes are causing full table scans.\n      - Check for inefficient joins or filter conditions.\n\n    5. **Provide Detailed Recommendations**:\n      - Suggest adding indexes on specific columns, explaining how they will improve performance.\n      - Recommend query rewrites with examples, if applicable.\n      - Propose schema changes if they can lead to significant improvements.\n\n    6. **Explain Your Reasoning Using Data**:\n      - Reference specific statistics, such as row counts, index usage metrics, and data distributions.\n      - Use this data to justify why certain recommendations will improve performance.\n\n    **Rules**:\n\n    - **Use the Tools Actively**: Before responding, always use the relevant tools to gather necessary information.\n\n    - **Do Not Mention the Tools**: Present all findings as your own analysis without referencing the tools or their outputs.\n\n    - **Be Specific and Data-Driven**: Use actual data, schema details, and execution plan insights in your recommendations.\n\n    - **Handle Errors Gracefully**: If a tool fails or returns an error, attempt to resolve it yourself. If unresolved, politely ask the user for more information.\n\n    **Example**:\n\n    *User*:\n    \"Why is this query running slowly? How can I optimize it?\n\n    \\`\\`\\`sql\n    SELECT c.name, COUNT(o.id) as order_count\n    FROM customers c\n    LEFT JOIN orders o ON c.id = o.customer_id\n    WHERE c.region = 'North America'\n    GROUP BY c.name;\n    \\`\\`\\`\n\n    *Assistant*:\n\n    \"After analyzing your query and database statistics, here's what I've found:\n\n    1. **Data Volume**:\n\n      - **customers**: 200,000 rows.\n      - **orders**: 5 million rows.\n\n    2. **Current Indexes**:\n\n      - **customers**: Index on \\`id\\` and \\`region\\`.\n      - **orders**: Index on \\`id\\` and \\`customer_id\\`.\n\n    3. **Execution Plan Insights**:\n\n      - The query is performing a sequential scan on the \\`customers\\` table.\n      - The left join is processing a large number of rows due to the high volume of \\`orders\\`.\n\n    4. **Specific Recommendations**:\n\n      - **Ensure Index on \\`customers(region)\\`**:\n\n        \\`\\`\\`sql\n        CREATE INDEX idx_customers_region ON customers(region);\n        \\`\\`\\`\n\n        This index will speed up the filtering of customers by \\`region\\`.\n\n      - **Optimize the Join Operation**:\n\n        Since you're performing an aggregate function after a left join, consider filtering the customers before the join:\n\n        \\`\\`\\`sql\n        SELECT c.name, COUNT(o.id) as order_count\n        FROM (\n          SELECT * FROM customers WHERE region = 'North America'\n        ) c\n        LEFT JOIN orders o ON c.id = o.customer_id\n        GROUP BY c.name;\n        \\`\\`\\`\n\n        This reduces the number of rows processed in the join.\n\n      - **Update Statistics**:\n\n        Run the following to help the query planner make better decisions:\n\n        \\`\\`\\`sql\n        ANALYZE customers;\n        ANALYZE orders;\n        \\`\\`\\`\n\n    5. **Expected Outcome**:\n\n      - **Faster Data Retrieval**: Indexing \\`region\\` accelerates the initial customer filtering.\n      - **Reduced Processing Time**: Filtering before the join minimizes the number of rows involved in the join and aggregation.\n      - **Better Query Planning**: Updated statistics allow for more efficient execution plans.\n\n    Implementing these changes should noticeably improve your query's performance.\"\n\n    6. **When a user asks for help in constructing a SQL query**\n\n      1. **Understand the Request**: Carefully read the user's requirements to grasp what data they need.\n\n      2. **Always use the tools to gather schema information**:\n        - Use **getPublicTablesWithColumns** to understand table structures and data types.\n        - Use **getForeignKeyConstraints** to understand relationships between tables.\n\n      3. **Construct the Query**:\n        - Based on the schema and relationships, write an appropriate SQL query that fulfills the user's requirements.\n        - Use proper joins and conditions as per the schema.\n        - Ensure the query is syntactically correct and efficient.\n\n      4. **Explain Your Reasoning**:\n        - Provide an explanation of how the query works.\n        - Reference specific tables and columns used.\n\n      **Rules**:\n\n      - **Use the Tools Actively**: Always use the relevant tools to gather necessary information before constructing the query.\n\n      - **Be Specific and Accurate**: Use actual schema details in your query and explanations.\n\n      - **Handle Errors Gracefully**: If a tool fails or returns an error, attempt to resolve it yourself. If unresolved, politely ask the user for more information.\n\n\n    **Remember**, always base your analysis on actual database details to provide the most accurate advice.\n`,\n    maxSteps: 22,\n    tools: {\n      ...postgresTools(connectionString, {\n        excludeTools: ['runQuery'],\n      }),\n    },\n  })\n\n  return result.toDataStreamResponse()\n}",
      "title": "Utils",
      "tools": [
        {
          "title": "getPublicTablesWithColumns",
          "description": "Get public tables with columns"
        },
        {
          "title": "getExplainForQuery",
          "description": "Get explain for a query"
        },
        {
          "title": "runQuery",
          "description": "Run a query"
        }
      ]
    }
  },
  "slack": {
    "author": "https://nicolasmontone.com",
    "name": "slack",
    "type": "registry:lib",
    "description": "Slack workspace integration tools for messaging and channel management. Features include sending messages, managing threads, channel operations, and workspace administration with full Slack markdown support.",
    "dependencies": [
      "zod",
      "ai",
      "@slack/web-api"
    ],
    "files": [
      {
        "path": "lib/tools/slack.ts",
        "type": "registry:lib",
        "content": "import { tool, type Tool } from 'ai'\nimport { z } from 'zod'\nimport { WebClient } from '@slack/web-api'\n\ntype SlackTools =\n  | 'sendMessage'\n  | 'sendThreadReply'\n  | 'getChannelHistory'\n  | 'getThreadReplies'\n  | 'listChannels'\n  | 'createChannel'\n  | 'inviteToChannel'\n  | 'setChannelTopic'\n\ninterface SlackMessage {\n  ts: string\n  text: string\n  user: string\n  thread_ts?: string\n  reply_count?: number\n}\n\ninterface SlackChannel {\n  id: string\n  name: string\n  topic?: { value: string }\n  purpose?: { value: string }\n  is_private: boolean\n  num_members: number\n}\n\nexport const slackTools = (\n  { token }: { token: string },\n  config?: {\n    excludeTools?: SlackTools[]\n  }\n): Partial<Record<SlackTools, Tool>> => {\n  const client = new WebClient(token)\n\n  const tools: Partial<Record<SlackTools, Tool>> = {\n    sendMessage: tool({\n      description: 'Send a message to a Slack channel or user',\n      parameters: z.object({\n        channel: z\n          .string()\n          .describe('Channel ID or name to send the message to'),\n        text: z\n          .string()\n          .describe(\n            'The message text to send, supports Slack markdown formatting'\n          ),\n        thread_ts: z\n          .string()\n          .optional()\n          .describe('Timestamp of the parent message to reply in a thread'),\n      }),\n      execute: async ({ channel, text, thread_ts }) => {\n        return sendMessage(client, { channel, text, thread_ts })\n      },\n    }),\n\n    sendThreadReply: tool({\n      description: 'Send a reply message in a specific thread',\n      parameters: z.object({\n        channel: z.string().describe('Channel ID where the thread is located'),\n        thread_ts: z\n          .string()\n          .describe('Timestamp of the parent message to reply to'),\n        text: z\n          .string()\n          .describe(\n            'The reply text to send, supports Slack markdown formatting'\n          ),\n      }),\n      execute: async ({ channel, thread_ts, text }) => {\n        return sendMessage(client, { channel, text, thread_ts })\n      },\n    }),\n\n    getChannelHistory: tool({\n      description: 'Get message history from a Slack channel',\n      parameters: z.object({\n        channel: z.string().describe('Channel ID to fetch history from'),\n        limit: z\n          .number()\n          .optional()\n          .describe('Number of messages to return (default: 100, max: 1000)'),\n        oldest: z\n          .string()\n          .optional()\n          .describe('Start of time range (timestamp) to include messages from'),\n        latest: z\n          .string()\n          .optional()\n          .describe('End of time range (timestamp) to include messages from'),\n      }),\n      execute: async ({ channel, limit, oldest, latest }) => {\n        return getChannelHistory(client, { channel, limit, oldest, latest })\n      },\n    }),\n\n    getThreadReplies: tool({\n      description: 'Get all replies in a specific thread',\n      parameters: z.object({\n        channel: z.string().describe('Channel ID where the thread is located'),\n        thread_ts: z\n          .string()\n          .describe('Timestamp of the parent message to get replies for'),\n        limit: z\n          .number()\n          .optional()\n          .describe('Number of replies to return (default: 100, max: 1000)'),\n      }),\n      execute: async ({ channel, thread_ts, limit }) => {\n        return getThreadReplies(client, { channel, thread_ts, limit })\n      },\n    }),\n\n    listChannels: tool({\n      description: 'List all channels in the workspace',\n      parameters: z.object({\n        exclude_archived: z\n          .boolean()\n          .optional()\n          .describe('Exclude archived channels from the list'),\n        types: z\n          .array(z.enum(['public_channel', 'private_channel']))\n          .optional()\n          .describe('Types of channels to include'),\n      }),\n      execute: async ({ exclude_archived, types }) => {\n        return listChannels(client, { exclude_archived, types })\n      },\n    }),\n\n    createChannel: tool({\n      description: 'Create a new Slack channel',\n      parameters: z.object({\n        name: z\n          .string()\n          .describe(\n            'Name of the channel (lowercase letters, numbers, hyphens only)'\n          ),\n        is_private: z\n          .boolean()\n          .optional()\n          .describe('Create a private channel instead of a public one'),\n        topic: z.string().optional().describe('Set the channel topic'),\n      }),\n      execute: async ({ name, is_private, topic }) => {\n        return createChannel(client, { name, is_private, topic })\n      },\n    }),\n\n    inviteToChannel: tool({\n      description: 'Invite users to a channel',\n      parameters: z.object({\n        channel: z.string().describe('Channel ID to invite users to'),\n        users: z\n          .array(z.string())\n          .describe('List of user IDs to invite to the channel'),\n      }),\n      execute: async ({ channel, users }) => {\n        return inviteToChannel(client, { channel, users })\n      },\n    }),\n\n    setChannelTopic: tool({\n      description: 'Set or update a channel topic',\n      parameters: z.object({\n        channel: z.string().describe('Channel ID to set the topic for'),\n        topic: z.string().describe('New topic text for the channel'),\n      }),\n      execute: async ({ channel, topic }) => {\n        return setChannelTopic(client, { channel, topic })\n      },\n    }),\n  }\n\n  for (const toolName in tools) {\n    if (config?.excludeTools?.includes(toolName as SlackTools)) {\n      delete tools[toolName as SlackTools]\n    }\n  }\n\n  return tools\n}\n\nasync function sendMessage(\n  client: WebClient,\n  {\n    channel,\n    text,\n    thread_ts,\n  }: { channel: string; text: string; thread_ts?: string }\n) {\n  try {\n    const result = await client.chat.postMessage({\n      channel,\n      text,\n      thread_ts,\n    })\n    return { ok: result.ok, ts: result.ts, channel: result.channel }\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function getChannelHistory(\n  client: WebClient,\n  {\n    channel,\n    limit = 100,\n    oldest,\n    latest,\n  }: {\n    channel: string\n    limit?: number\n    oldest?: string\n    latest?: string\n  }\n) {\n  try {\n    const result = await client.conversations.history({\n      channel,\n      limit,\n      oldest,\n      latest,\n    })\n    return {\n      ok: result.ok,\n      messages: result.messages as SlackMessage[],\n    }\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function getThreadReplies(\n  client: WebClient,\n  {\n    channel,\n    thread_ts,\n    limit = 100,\n  }: {\n    channel: string\n    thread_ts: string\n    limit?: number\n  }\n) {\n  try {\n    const result = await client.conversations.replies({\n      channel,\n      ts: thread_ts,\n      limit,\n    })\n    return {\n      ok: result.ok,\n      messages: result.messages as SlackMessage[],\n    }\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function listChannels(\n  client: WebClient,\n  {\n    exclude_archived = true,\n    types = ['public_channel'],\n  }: {\n    exclude_archived?: boolean\n    types?: ('public_channel' | 'private_channel')[]\n  }\n) {\n  try {\n    const result = await client.conversations.list({\n      exclude_archived,\n      types: types.join(','),\n    })\n    return {\n      ok: result.ok,\n      channels: result.channels as SlackChannel[],\n    }\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function createChannel(\n  client: WebClient,\n  {\n    name,\n    is_private = false,\n    topic,\n  }: {\n    name: string\n    is_private?: boolean\n    topic?: string\n  }\n) {\n  try {\n    const result = await client.conversations.create({\n      name,\n      is_private,\n    })\n\n    if (topic && result.ok && result.channel?.id) {\n      await client.conversations.setTopic({\n        channel: result.channel.id,\n        topic,\n      })\n    }\n\n    return { ok: result.ok, channel: result.channel as SlackChannel }\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function inviteToChannel(\n  client: WebClient,\n  { channel, users }: { channel: string; users: string[] }\n) {\n  try {\n    const result = await client.conversations.invite({\n      channel,\n      users: users.join(','),\n    })\n    return { ok: result.ok, channel: result.channel }\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n\nasync function setChannelTopic(\n  client: WebClient,\n  { channel, topic }: { channel: string; topic: string }\n) {\n  try {\n    const result = await client.conversations.setTopic({\n      channel,\n      topic,\n    })\n    return { ok: result.ok, topic }\n  } catch (error) {\n    return { error: String(error) }\n  }\n}\n",
        "target": ""
      }
    ],
    "ui": {
      "beta": false,
      "usage": "import { openai } from '@ai-sdk/openai'\nimport { streamText, convertToCoreMessages } from 'ai'\nimport { slackTools } from '@/lib/tools/slack'\n// Allow streaming responses up to 30 seconds\nexport const maxDuration = 30\n\nexport async function POST(req: Request) {\n  const { messages } = await req.json()\n\n  const slackToken = process.env.SLACK_TOKEN\n\n  if (!slackToken) {\n    return new Response('No Slack token provided', { status: 400 })\n  }\n\n  const result = await streamText({\n    model: openai('gpt-4o'),\n    messages: convertToCoreMessages(messages),\n    system: `\n    You are a Slack workspace expert specializing in channel management, messaging, and thread organization. Your goal is to help users effectively manage their Slack workspaces and communication workflows by providing detailed assistance and specific recommendations.\n\n    When users interact with Slack workspaces, you should:\n\n    1. **Message Management**:\n      - Help users send well-formatted messages with proper Slack markdown\n      - Assist in creating and managing message threads\n      - Guide users through message history and thread replies\n      - Help organize conversations effectively\n\n    2. **Channel Management**:\n      - Help create and configure channels with appropriate settings\n      - Assist in managing channel topics and purposes\n      - Guide users through channel invitations and member management\n      - Help maintain channel organization\n\n    3. **Workspace Organization**:\n      - Provide guidance on channel structure and naming conventions\n      - Help set up channels for specific projects or teams\n      - Assist in managing public vs. private channels\n      - Guide users on best practices for workspace organization\n\n    **Rules and Guidelines**:\n\n    1. **Sending Messages**:\n      - Use appropriate formatting (bold, italic, lists) for clarity\n      - Consider thread usage for organized discussions\n      - Include relevant context in messages\n      - Use channel mentions and user mentions appropriately\n\n    2. **Channel Operations**:\n      - Follow naming conventions (lowercase, hyphens)\n      - Set clear, descriptive channel topics\n      - Consider privacy settings (public vs. private)\n      - Manage member access appropriately\n\n    3. **Thread Management**:\n      - Use threads to keep conversations organized\n      - Maintain context within thread replies\n      - Consider when to move discussions to new channels\n      - Archive or clean up old threads when appropriate\n\n    **Example Interactions**:\n\n    1. **Sending a Formatted Message**:\n    User: \"I need to send an announcement about system maintenance\"\n\n    Response: \"I'll help you create a well-formatted announcement message. Here's how we'll structure it:\n\n    \\`\\`\\`\n    :warning: *System Maintenance Notice* :warning:\n\n    Hello team! Important announcement regarding upcoming system maintenance:\n\n    *When:* Monday, March 15th at 2:00 PM EST\n    *Duration:* Approximately 2 hours\n    *Impact:* System will be in read-only mode\n\n    *What to expect:*\n    • All services will be in read-only mode\n    • No data loss will occur\n    • Real-time updates will be posted in this thread\n\n    *Action Required:*\n    1. Save all pending work before 1:45 PM EST\n    2. Log out of the system by 1:55 PM EST\n    3. Check this thread for status updates\n\n    For urgent issues during maintenance, contact @oncall-team\n    \\`\\`\\`\n\n    I'll send this to the #system-announcements channel and create a thread for updates.\"\n\n    2. **Creating a New Channel**:\n    User: \"We need a channel for the new mobile app project\"\n\n    Response: \"I'll help you set up a well-structured channel for the mobile app project:\n\n    1. **Channel Setup**:\n       - Name: 'mobile-app-dev'\n       - Privacy: Private (for development team only)\n       - Topic: 'Mobile App Development - Sprint discussions and updates'\n\n    2. **Initial Setup Tasks**:\n       - Invite core development team members\n       - Set channel topic with project goals\n       - Create pinned post with project resources\n\n    3. **Channel Structure**:\n       - Pin important documents and links\n       - Set up thread categories for:\n         • Daily standups\n         • Sprint planning\n         • Technical discussions\n         • Release coordination\n\n    Would you like me to create this channel with these settings?\"\n\n    3. **Managing Thread Discussions**:\n    User: \"How should we organize the technical discussion threads?\"\n\n    Response: \"I'll help you set up an organized thread structure:\n\n    1. **Thread Categories**:\n       - 🔧 Technical Decisions\n       - 🐛 Bug Reports\n       - 📱 Feature Discussions\n       - 📊 Performance Updates\n\n    2. **Thread Guidelines**:\n       - Start with clear, categorized headers\n       - Use bullet points for key points\n       - Include code snippets in formatted blocks\n       - Tag relevant team members\n\n    3. **Example Thread Structure**:\n    \\`\\`\\`\n    🔧 *Technical Decision: Authentication Flow*\n\n    *Current Status:* Discussion\n    *Decision Needed By:* Friday, March 18th\n    *Stakeholders:* @security-team @frontend-team\n\n    *Options Being Considered:*\n    1. OAuth 2.0 with JWT\n    2. Session-based auth\n    3. Hybrid approach\n\n    *Key Considerations:*\n    • Security requirements\n    • Performance impact\n    • User experience\n    • Implementation timeline\n\n    Please reply in thread with feedback and concerns.\n    \\`\\`\\`\n\n    Would you like me to set up these thread templates in your channel?\"\n\n    Remember to:\n    - Always verify message permissions before sending\n    - Use appropriate formatting for different message types\n    - Consider channel privacy settings\n    - Maintain professional communication\n    - Follow workspace-specific guidelines\n    - Use data-driven insights for recommendations\n\n    Your responses should be:\n    - Clear and well-formatted\n    - Context-appropriate\n    - Action-oriented\n    - Professional in tone\n    - Consistent with Slack best practices\n    `,\n    maxSteps: 22,\n    tools: {\n      ...slackTools({ token: slackToken }, { excludeTools: ['inviteToChannel'] }),\n    },\n  })\n\n  return result.toDataStreamResponse()\n} ",
      "title": "Platforms",
      "tools": [
        {
          "title": "sendMessage",
          "description": "Send a message to a Slack channel"
        },
        {
          "title": "sendThreadReply",
          "description": "Send a reply to a thread in a Slack channel"
        },
        {
          "title": "getChannelHistory",
          "description": "Get the history of a Slack channel"
        },
        {
          "title": "getThreadReplies",
          "description": "Get the replies to a thread in a Slack channel"
        },
        {
          "title": "listChannels",
          "description": "List all channels in a Slack workspace"
        },
        {
          "title": "createChannel",
          "description": "Create a new channel in a Slack workspace"
        },
        {
          "title": "inviteToChannel",
          "description": "Invite a user to a Slack channel"
        },
        {
          "title": "setChannelTopic",
          "description": "Set the topic of a Slack channel"
        }
      ]
    }
  },
  "tavily": {
    "author": "https://nicolasmontone.com",
    "name": "tavily",
    "type": "registry:lib",
    "description": "Tavily search API integration offering advanced web search capabilities. Includes comprehensive search, context-aware search, Q&A functionality, and content extraction from URLs with customizable search parameters.",
    "dependencies": [
      "zod",
      "ai",
      "@tavily/core"
    ],
    "files": [
      {
        "path": "lib/tools/tavily.ts",
        "type": "registry:lib",
        "content": "import { tool, type Tool } from 'ai'\nimport { z } from 'zod'\nimport { tavily } from '@tavily/core'\n\ntype TavilyTools = 'search' | 'searchContext' | 'searchQNA' | 'extract'\n\ninterface TavilyImage {\n  url: string\n  description?: string\n}\n\ninterface TavilySearchResult {\n  title: string\n  url: string\n  content: string\n  rawContent?: string\n  score: number\n  publishedDate?: string\n}\n\ninterface TavilySearchResponse {\n  query: string\n  answer?: string\n  images?: TavilyImage[]\n  results: TavilySearchResult[]\n  responseTime: number\n  error?: string // Added to handle errors\n}\n\ninterface TavilyExtractResult {\n  url: string\n  rawContent: string\n  images?: string[]\n  error?: string\n}\n\ninterface TavilyExtractResponse {\n  results: TavilyExtractResult[]\n  error?: string\n}\n\nexport const tavilyTools = (\n  { apiKey }: { apiKey: string },\n  config?: {\n    excludeTools?: TavilyTools[]\n  }\n): Partial<Record<TavilyTools, Tool>> => {\n  const client = tavily({ apiKey })\n\n  const tools: Partial<Record<TavilyTools, Tool>> = {\n    search: tool({\n      description:\n        'Perform a comprehensive web search and get detailed results including optional images and AI-generated answers',\n      parameters: z.object({\n        query: z\n          .string()\n          .describe('The search query to find information about'),\n        searchDepth: z\n          .enum(['basic', 'advanced'])\n          .optional()\n          .describe(\n            'Depth of search - basic is faster, advanced is more thorough'\n          ),\n        topic: z\n          .enum(['general', 'news'])\n          .optional()\n          .describe(\n            'Category of search - general for broad searches, news for recent events'\n          ),\n        days: z\n          .number()\n          .optional()\n          .describe(\n            'Number of days back to search (only works with news topic, defaults to 3)'\n          ),\n        timeRange: z\n          .enum(['day', 'week', 'month', 'year', 'd', 'w', 'm', 'y'])\n          .optional()\n          .describe('Time range for results - alternative to days parameter'),\n        maxResults: z\n          .number()\n          .optional()\n          .describe('Maximum number of results to return (default: 5)'),\n        includeImages: z\n          .boolean()\n          .optional()\n          .describe('Include related images in the response'),\n        includeImageDescriptions: z\n          .boolean()\n          .optional()\n          .describe(\n            'Add descriptive text for each image (requires includeImages)'\n          ),\n        includeAnswer: z\n          .boolean()\n          .optional()\n          .describe(\n            'Include AI-generated answer to query - basic is quick, advanced is detailed'\n          ),\n        includeRawContent: z\n          .boolean()\n          .optional()\n          .describe('Include cleaned HTML content of each result'),\n        includeDomains: z\n          .array(z.string())\n          .optional()\n          .describe('List of domains to specifically include in results'),\n        excludeDomains: z\n          .array(z.string())\n          .optional()\n          .describe('List of domains to exclude from results'),\n      }),\n      execute: async ({ query, ...options }) => {\n        try {\n          return await client.search(query, {\n            ...options,\n          })\n        } catch (error) {\n          return { error: String(error) } as TavilySearchResponse\n        }\n      },\n    }),\n    searchContext: tool({\n      description:\n        'Search the web and get content and sources within a specified token limit, optimized for context retrieval',\n      parameters: z.object({\n        query: z\n          .string()\n          .describe('The search query to find information about'),\n        maxTokens: z\n          .number()\n          .optional()\n          .describe('Maximum number of tokens in the response (default: 4000)'),\n        searchDepth: z\n          .enum(['basic', 'advanced'])\n          .optional()\n          .describe(\n            'Depth of search - basic is faster, advanced is more thorough'\n          ),\n        topic: z\n          .enum(['general', 'news'])\n          .optional()\n          .describe(\n            'Category of search - general for broad searches, news for recent events'\n          ),\n        days: z\n          .number()\n          .optional()\n          .describe(\n            'Number of days back to search (only works with news topic)'\n          ),\n        maxResults: z\n          .number()\n          .optional()\n          .describe('Maximum number of results to return'),\n        includeDomains: z\n          .array(z.string())\n          .optional()\n          .describe('List of domains to specifically include in results'),\n        excludeDomains: z\n          .array(z.string())\n          .optional()\n          .describe('List of domains to exclude from results'),\n      }),\n      execute: async ({ query, ...options }) => {\n        try {\n          return await client.searchContext(query, options)\n        } catch (error) {\n          return String(error)\n        }\n      },\n    }),\n    searchQNA: tool({\n      description:\n        'Search the web and get a direct answer to your question, optimized for AI agent interactions',\n      parameters: z.object({\n        query: z.string().describe('The question to find an answer for'),\n        searchDepth: z\n          .enum(['basic', 'advanced'])\n          .optional()\n          .describe(\n            'Depth of search - defaults to advanced for better answers'\n          ),\n        topic: z\n          .enum(['general', 'news'])\n          .optional()\n          .describe(\n            'Category of search - general for broad searches, news for recent events'\n          ),\n        days: z\n          .number()\n          .optional()\n          .describe(\n            'Number of days back to search (only works with news topic)'\n          ),\n        maxResults: z\n          .number()\n          .optional()\n          .describe('Maximum number of results to consider'),\n        includeDomains: z\n          .array(z.string())\n          .optional()\n          .describe('List of domains to specifically include in results'),\n        excludeDomains: z\n          .array(z.string())\n          .optional()\n          .describe('List of domains to exclude from results'),\n      }),\n      execute: async ({ query, ...options }) => {\n        try {\n          return await client.searchQNA(query, options)\n        } catch (error) {\n          return String(error)\n        }\n      },\n    }),\n    extract: tool({\n      description: 'Extract content and optionally images from a list of URLs',\n      parameters: z.object({\n        urls: z\n          .array(z.string().url())\n          .max(20)\n          .describe('List of URLs to extract content from (maximum 20 URLs)'),\n      }),\n      execute: async ({ urls }) => {\n        try {\n          const response = await client.extract(urls)\n          return {\n            results: response.results.map((result) => ({\n              url: result.url,\n              rawContent: result.rawContent,\n            })),\n          } as TavilyExtractResponse\n        } catch (error) {\n          return {\n            results: [],\n            error: String(error),\n          } as TavilyExtractResponse\n        }\n      },\n    }),\n  }\n\n  for (const toolName in tools) {\n    if (config?.excludeTools?.includes(toolName as TavilyTools)) {\n      delete tools[toolName as TavilyTools]\n    }\n  }\n\n  return tools\n}\n",
        "target": ""
      }
    ],
    "ui": {
      "beta": false,
      "usage": "import { openai } from '@ai-sdk/openai'\nimport { streamText, convertToCoreMessages } from 'ai'\nimport { tavilyTools } from '@/lib/tools/tavily'\n// Allow streaming responses up to 30 seconds\nexport const maxDuration = 30\n\nexport async function POST(req: Request) {\n  const { messages } = await req.json()\n\n  const apiKey = process.env.TAVILY_API_KEY\n\n  if (!apiKey) {\n    return new Response('No API key provided', { status: 400 })\n  }\n\n  const result = await streamText({\n    model: openai('gpt-4o'),\n    messages: convertToCoreMessages(messages),\n    system: `\n    You are an expert Research Assistant specializing in comprehensive information gathering and analysis. Your goal is to help users find accurate, detailed, and relevant information across various topics, from academic research to current events, using advanced search capabilities.\n\n    When handling research requests, you should:\n\n    1. **Understand Research Requirements**:\n       - Identify the core topic and subtopics\n       - Determine the depth of research needed\n       - Note any specific time constraints or source preferences\n       - Consider academic vs. general audience needs\n\n    2. **Choose the Optimal Search Strategy**:\n       For General Research:\n       - Use **search** for broad topics requiring comprehensive coverage\n       - Include images when they enhance understanding\n       - Enable AI-generated answers for quick summaries\n       - Adjust search depth based on complexity\n\n       For Academic/Technical Research:\n       - Use **searchContext** for detailed technical information\n       - Focus on credible academic sources\n       - Maintain higher token limits for thorough coverage\n       - Prioritize peer-reviewed content\n\n       For Fact-Checking/Q&A:\n       - Use **searchQNA** for direct answers to specific questions\n       - Verify information across multiple sources\n       - Provide citations and references\n       - Focus on accuracy and credibility\n\n       For Content Analysis:\n       - Use **extract** for deep dives into specific sources\n       - Process multiple related URLs\n       - Extract key information and insights\n       - Compare information across sources\n\n    3. **Optimize Search Parameters**:\n       - Adjust search depth (basic/advanced) based on complexity\n       - Set appropriate time ranges for historical vs. current topics\n       - Filter domains for credibility and relevance\n       - Balance breadth vs. depth of coverage\n\n    **Example Usage**:\n\n    *User*: \"Research recent developments in quantum computing and their potential impact on cryptography\"\n\n    *Assistant*: \"I'll conduct a comprehensive research analysis:\n\n    1. Initial Broad Search:\n       - Using advanced search depth for technical accuracy\n       - Including both academic and industry sources\n       - Focusing on recent developments (last 6 months)\n       - Including relevant technical diagrams/images\n\n    2. Technical Deep Dive:\n       - Extracting content from key research papers\n       - Focusing on quantum cryptography implications\n       - Including expert opinions and analyses\n       - Gathering technical specifications and benchmarks\n\n    3. Impact Analysis:\n       - Searching for real-world applications\n       - Gathering industry expert perspectives\n       - Including security implications\n       - Analyzing future predictions\n\n    The results will include:\n    - Latest research findings\n    - Technical specifications\n    - Expert opinions\n    - Visual aids and diagrams\n    - Industry implications\n    - Security considerations\n    - Future outlook\n\n    This will provide you with a comprehensive understanding of quantum computing's current state and its implications for cryptography.\"\n\n    **Research Best Practices**:\n    - Verify information across multiple sources\n    - Prioritize peer-reviewed and authoritative sources\n    - Include diverse perspectives when relevant\n    - Provide proper citations and references\n    - Balance technical depth with accessibility\n    - Consider practical applications\n    - Acknowledge limitations and uncertainties\n\n    Your responses should be:\n    1. Well-researched and accurate\n    2. Properly cited and referenced\n    3. Logically structured and organized\n    4. Balanced in perspective\n    5. Clear and accessible\n    6. Technically precise when needed\n    7. Practical and applicable\n    `,\n    maxSteps: 22,\n    tools: {\n      ...tavilyTools({ apiKey }, {\n        excludeTools: [],\n      }),\n    },\n  })\n\n  return result.toDataStreamResponse()\n} ",
      "title": "Search",
      "tools": [
        {
          "title": "search",
          "description": "Search for information on Tavily"
        },
        {
          "title": "searchContext",
          "description": "Search for information on Tavily with context"
        },
        {
          "title": "searchQNA",
          "description": "Search for information on Tavily with Q&A"
        },
        {
          "title": "extract",
          "description": "Extract information from a URL"
        }
      ]
    }
  },
  "vercel": {
    "author": "https://nicolasmontone.com",
    "name": "vercel",
    "type": "registry:lib",
    "description": "Vercel platform integration tools for deployment and project management. Enables interaction with Vercel services for managing deployments, domains, and project configurations.",
    "dependencies": [
      "zod",
      "ai",
      "@vercel/sdk"
    ],
    "files": [
      {
        "path": "lib/tools/vercel.ts",
        "type": "registry:lib",
        "content": "import { tool, type Tool } from 'ai'\nimport { z } from 'zod'\nimport { Vercel } from '@vercel/sdk'\n\ntype VercelTools = 'searchProjects' | 'searchDeployments' | 'searchDomains'\n\nconst tokenSchema = z.string().describe('The Vercel API token').min(24)\n\nexport const vercelTools = (\n  { token }: { token: string },\n  config?: { excludeTools?: VercelTools[] }\n): Partial<Record<VercelTools, Tool>> => {\n  const tokenParsed = tokenSchema.safeParse(token)\n  if (!tokenParsed.success) {\n    throw new Error('Invalid Vercel API token')\n  }\n  const client = new Vercel({ bearerToken: token })\n  const tools: Partial<Record<VercelTools, Tool>> = {\n    searchProjects: tool({\n      description: 'Search for projects in Vercel',\n      parameters: z.object({}),\n      execute: async () => {\n        const response = await searchProjects(client)\n        return response\n      },\n    }),\n    searchDeployments: tool({\n      description: 'Search for deployments in Vercel',\n      parameters: z.object({\n        query: z.string().describe('The search query to find deployments'),\n      }),\n      execute: async ({ query }) => {\n        const response = await searchDeployments(client, query)\n        return response\n      },\n    }),\n    searchDomains: tool({\n      description: 'Search for domains in Vercel',\n      parameters: z.object({}),\n      execute: async () => {\n        const response = await searchDomains(client)\n        return response\n      },\n    }),\n  }\n\n  for (const toolName in tools) {\n    if (config?.excludeTools?.includes(toolName as VercelTools)) {\n      delete tools[toolName as VercelTools]\n    }\n  }\n\n  return tools\n}\n\nfunction searchProjects(client: Vercel) {\n  return client.projects.getProjects({\n    limit: '20',\n  })\n}\n\nfunction searchDeployments(client: Vercel, query: string) {\n  return client.deployments.getDeployments({\n    limit: 20,\n    projectId: query,\n  })\n}\n\nfunction searchDomains(client: Vercel) {\n  return client.domains.getDomains({\n    limit: 20,\n  })\n}\n",
        "target": ""
      }
    ],
    "ui": {
      "beta": false,
      "usage": "import { openai } from '@ai-sdk/openai'\nimport { streamText, convertToCoreMessages } from 'ai'\nimport { vercelTools } from '@/lib/tools/vercel'\n// Allow streaming responses up to 30 seconds\nexport const maxDuration = 30\n\nexport async function POST(req: Request) {\n  const { messages } = await req.json()\n\n  const token = process.env.VERCEL_TOKEN\n\n  if (!token) {\n    return new Response('No Vercel token provided', { status: 400 })\n  }\n\n  const result = await streamText({\n    model: openai('gpt-4o'),\n    messages: convertToCoreMessages(messages),\n    system: `\n    You are a Cloud Platforms Expert specializing in helping teams understand and manage their resources across multiple cloud platforms including AWS, Azure, Google Cloud, and Vercel. Your goal is to provide teams with clear insights into their cloud infrastructure and deployments across all platforms.\n\n    When a user makes a request about cloud resources, you should:\n\n    1. **Understand the Platform Scope**:\n       - Identify which cloud platforms are relevant to the request\n       - Determine if this is a cross-platform or platform-specific query\n       - Note any need for comparing resources across platforms\n\n    2. **Resource Discovery and Management**:\n       AWS Resources:\n       - EC2 instances and configurations\n       - S3 buckets and storage solutions\n       - Lambda functions and serverless resources\n       - RDS databases and configurations\n       - CloudFront distributions\n\n       Azure Resources:\n       - Virtual Machines and configurations\n       - Azure Storage accounts\n       - Azure Functions\n       - Azure SQL databases\n       - Azure CDN endpoints\n\n       Google Cloud Resources:\n       - Compute Engine instances\n       - Cloud Storage buckets\n       - Cloud Functions\n       - Cloud SQL instances\n       - Cloud CDN configurations\n\n       Vercel Resources:\n       - Projects and their configurations\n       - Deployments and their status\n       - Domain configurations and DNS settings\n\n    3. **Cross-Platform Operations**:\n       - Compare similar resources across platforms\n       - Identify cost optimization opportunities\n       - Analyze performance metrics\n       - Review security configurations\n       - Track resource utilization\n\n    **Platform-Specific Tools**:\n\n    1. **Vercel Operations**:\n       - Use searchProjects to list all Vercel projects\n       - Use searchDeployments for deployment tracking\n       - Use searchDomains for domain management\n\n    2. **AWS Operations** (Coming Soon):\n       - EC2 instance management\n       - S3 bucket operations\n       - Lambda function handling\n       - RDS database management\n\n    3. **Azure Operations** (Coming Soon):\n       - VM management\n       - Storage account operations\n       - Function App handling\n       - Database management\n\n    4. **Google Cloud Operations** (Coming Soon):\n       - GCE instance management\n       - Cloud Storage operations\n       - Cloud Function handling\n       - Cloud SQL management\n\n    **Example Usage**:\n\n    *User*: \"Show me an overview of our team's cloud resources\"\n\n    *Assistant*: \"I'll help you get a comprehensive view of your cloud resources:\n\n    1. Vercel Infrastructure:\n       - Using searchProjects to list all active projects\n       - Checking recent deployments across projects\n       - Reviewing domain configurations\n\n    2. AWS Resources (Coming Soon):\n       - EC2 instances and their status\n       - S3 bucket usage and configurations\n       - Lambda functions overview\n       - RDS database status\n\n    3. Azure Resources (Coming Soon):\n       - VM status and configurations\n       - Storage account usage\n       - Function Apps overview\n       - Database status\n\n    4. Google Cloud Resources (Coming Soon):\n       - Compute Engine instances\n       - Cloud Storage usage\n       - Cloud Functions overview\n       - Cloud SQL status\n\n    The results will include:\n    - Resource utilization\n    - Deployment status\n    - Performance metrics\n    - Cost information\n    - Security configurations\n\n    This will give you a complete overview of your cloud infrastructure across all platforms.\"\n\n    **Remember**:\n    - Verify authentication for each platform\n    - Handle rate limits appropriately\n    - Provide clear error messages\n    - Format responses for readability\n    - Include relevant metadata\n    - Consider cost implications\n    - Monitor security aspects\n\n    Your responses should be:\n    1. Comprehensive across platforms\n    2. Clear and well-structured\n    3. Security-conscious\n    4. Cost-aware\n    5. Performance-focused\n    `,\n    maxSteps: 22,\n    tools: {\n      ...vercelTools({ token }, {\n        excludeTools: [],\n      }),\n    },\n  })\n\n  return result.toDataStreamResponse()\n} ",
      "title": "Platforms",
      "tools": [
        {
          "title": "searchProjects",
          "description": "Search for projects in Vercel"
        },
        {
          "title": "searchDeployments",
          "description": "Search for deployments in Vercel"
        },
        {
          "title": "searchDomains",
          "description": "Search for domains in Vercel"
        }
      ]
    }
  },
  "fal": {
    "author": "https://nicolasmontone.com",
    "name": "fal",
    "type": "registry:lib",
    "description": "Fal.ai image generation tools",
    "dependencies": [
      "zod",
      "ai",
      "@ai-sdk/fal"
    ],
    "files": [
      {
        "path": "lib/tools/fal.ts",
        "type": "registry:lib",
        "content": "import { createFal } from '@ai-sdk/fal'\nimport {\n  experimental_generateImage as generateImage,\n  tool,\n  type Tool,\n} from 'ai'\nimport { z } from 'zod'\n\nexport type FalTools = 'createImage'\n\nconst models = [\n  'fal-ai/aura-flow',\n  'fal-ai/aura-sr',\n  'fal-ai/bria/eraser',\n  'fal-ai/bria/product-shot',\n  'fal-ai/bria/text-to-image/base',\n  'fal-ai/bria/text-to-image/fast',\n  'fal-ai/bria/text-to-image/hd',\n  'fal-ai/bria/text-to-image/turbo',\n  'fal-ai/ccsr',\n  'fal-ai/clarity-upscaler',\n  'fal-ai/creative-upscaler',\n  'fal-ai/esrgan',\n  'fal-ai/flux-general',\n  'fal-ai/flux-general/differential-diffusion',\n  'fal-ai/flux-general/image-to-image',\n  'fal-ai/flux-general/inpainting',\n  'fal-ai/flux-general/rf-inversion',\n  'fal-ai/flux-lora',\n  'fal-ai/flux-lora/image-to-image',\n  'fal-ai/flux-lora/inpainting',\n  'fal-ai/flux-pro/v1.1',\n  'fal-ai/flux-pro/v1.1-ultra',\n  'fal-ai/flux-pro/v1.1-ultra-finetuned',\n  'fal-ai/flux-pro/v1.1-ultra/redux',\n  'fal-ai/flux-pro/v1.1/redux',\n  'fal-ai/flux/dev',\n  'fal-ai/flux/dev/image-to-image',\n  'fal-ai/flux/dev/redux',\n  'fal-ai/flux/schnell',\n  'fal-ai/flux/schnell/redux',\n  'fal-ai/hyper-sdxl',\n  'fal-ai/ideogram/v2',\n  'fal-ai/ideogram/v2/remix',\n  'fal-ai/ideogram/v2/turbo',\n  'fal-ai/ideogram/v2/turbo/edit',\n  'fal-ai/ideogram/v2/turbo/remix',\n  'fal-ai/janus',\n  'fal-ai/luma-photon',\n  'fal-ai/luma-photon/flash',\n  'fal-ai/omnigen-v1',\n  'fal-ai/playground-v25',\n  'fal-ai/recraft-20b',\n  'fal-ai/recraft-v3',\n  'fal-ai/sana',\n  'fal-ai/stable-cascade',\n  'fal-ai/stable-diffusion-3.5-large',\n  'fal-ai/stable-diffusion-3.5-medium',\n  'fashn/tryon',\n] as const\n\ntype FalModel = (typeof models)[number] | (string & {})\n\nexport const falTools = (\n  { apiKey, model }: { apiKey: string; model?: FalModel },\n  config?: {\n    excludeTools?: FalTools[]\n  }\n): Partial<Record<FalTools, Tool>> => {\n  if (\n    !models.includes((model || 'fal-ai/flux-pro/v1.1') as (typeof models)[number])\n  ) {\n    throw new Error('Invalid model')\n  }\n\n  const tools: Partial<Record<FalTools, Tool>> = {\n    createImage: tool({\n      description: 'Create an image based on the prompt',\n      parameters: z.object({\n        prompt: z.string().describe('The prompt to create an image based on'),\n      }),\n      execute: async ({ prompt }) => {\n        return await createImage(prompt, model ?? 'fal-ai/flux-pro/v1.1', apiKey)\n      },\n    }),\n  }\n\n  if (config?.excludeTools) {\n    for (const toolName in tools) {\n      if (config.excludeTools.includes(toolName as FalTools)) {\n        delete tools[toolName as FalTools]\n      }\n    }\n  }\n\n  return tools\n}\n\nasync function createImage(prompt: string, model: FalModel, apiKey: string) {\n  const fal = createFal({\n    apiKey,\n  })\n  return await generateImage({\n    model: fal.image(model),\n    prompt,\n  })\n}\n",
        "target": ""
      }
    ],
    "ui": {
      "usage": "import { openai } from '@ai-sdk/openai'\nimport { streamText, convertToCoreMessages } from 'ai'\nimport { falTools } from '@/tools/fal'\n// Allow streaming responses up to 30 seconds\nexport const maxDuration = 30\n\nconst apiKey = process.env.FAL_API_KEY as string\n\nif (!apiKey) {\n  throw new Error('FAL_API_KEY is not set')\n}\n\nexport async function POST(req: Request) {\n  const { messages } = await req.json()\n\n  const result = await streamText({\n    model: openai('gpt-4o'),\n    messages: convertToCoreMessages(messages),\n    system: `\n    You are an Image Generation Expert specializing in creating and manipulating images using Fal.ai's powerful models. Your goal is to help users generate high-quality images based on their prompts and requirements.\n\n    When handling image generation requests, you should:\n\n    1. **Analyze the Request**:\n      - Understand the desired image style and content\n      - Note any specific requirements or constraints\n      - Evaluate prompt clarity and effectiveness\n\n    2. **Available Image Operations**:\n\n      Image Generation:\n      - createImage: Generate an image from a text prompt\n        * Supports various models for different use cases\n        * Handles natural language descriptions\n        * Creates high-quality visual outputs\n\n    3. **Best Practices**:\n\n      Prompt Engineering:\n      - Be specific and descriptive\n      - Include style references when needed\n      - Specify important details\n      - Use clear, unambiguous language\n\n      Model Selection:\n      - Choose based on use case\n      - Consider speed vs. quality tradeoffs\n      - Match model capabilities to requirements\n      - Use specialized models when appropriate\n\n    **Example Interactions**:\n\n    *User*: \"Create a realistic photo of a sunset over mountains\"\n\n    *Assistant*: \"I'll help you generate a beautiful sunset image:\n\n    1. **Generation Parameters**:\n       Prompt: A breathtaking sunset over majestic mountain peaks, golden hour lighting, \n       photorealistic, dramatic clouds, high detail, professional photography\n\n    Would you like to:\n    - Adjust the lighting details?\n    - Specify a particular mountain range?\n    - Add foreground elements?\n    - Change the time of day?\"\n\n    *User*: \"Generate an artistic portrait in anime style\"\n\n    *Assistant*: \"I'll create an anime-style portrait:\n\n    1. **Generation Parameters**:\n       Prompt: Artistic anime portrait, vibrant colors, detailed eyes, \n       soft lighting, studio ghibli inspired, clean lines, expressive features\n\n    Would you like to:\n    - Modify the art style?\n    - Change the character features?\n    - Adjust the color palette?\n    - Add specific background elements?\"\n\n    **Remember**:\n    - Provide clear, detailed prompts\n    - Consider image quality requirements\n    - Handle errors gracefully\n\n    When handling requests, focus on creating high-quality images while providing clear guidance on prompt engineering and model selection.`,\n    maxSteps: 10,\n    tools: {\n      ...falTools({\n        apiKey,\n      }),\n    },\n  })\n\n  return result.toDataStreamResponse()\n}\n",
      "title": "Image Generation",
      "tools": [
        {
          "title": "createImage",
          "description": "Create an image based on a prompt"
        }
      ],
      "beta": true
    }
  },
  "replicate": {
    "author": "https://nicolasmontone.com",
    "name": "replicate",
    "type": "registry:lib",
    "description": "Replicate image generation tools",
    "dependencies": [
      "zod",
      "ai",
      "@ai-sdk/replicate"
    ],
    "files": [
      {
        "path": "lib/tools/replicate.ts",
        "type": "registry:lib",
        "content": "import { createReplicate } from '@ai-sdk/replicate'\n\nimport {\n  experimental_generateImage as generateImage,\n  tool,\n  type Tool,\n} from 'ai'\nimport { z } from 'zod'\n\nexport type ReplicateTools = 'createImage'\n\nconst replicateModels = [\n  'black-forest-labs/flux-1.1-pro',\n  'black-forest-labs/flux-1.1-pro-ultra',\n  'black-forest-labs/flux-dev',\n  'black-forest-labs/flux-pro',\n  'black-forest-labs/flux-schnell',\n  'bytedance/sdxl-lightning-4step',\n  'fofr/aura-flow',\n  'fofr/latent-consistency-model',\n  'fofr/realvisxl-v3-multi-controlnet-lora',\n  'fofr/sdxl-emoji',\n  'fofr/sdxl-multi-controlnet-lora',\n  'ideogram-ai/ideogram-v2',\n  'ideogram-ai/ideogram-v2-turbo',\n  'lucataco/dreamshaper-xl-turbo',\n  'lucataco/open-dalle-v1.1',\n  'lucataco/realvisxl-v2.0',\n  'lucataco/realvisxl2-lcm',\n  'luma/photon',\n  'luma/photon-flash',\n  'nvidia/sana',\n  'playgroundai/playground-v2.5-1024px-aesthetic',\n  'recraft-ai/recraft-v3',\n  'recraft-ai/recraft-v3-svg',\n  'stability-ai/stable-diffusion-3.5-large',\n  'stability-ai/stable-diffusion-3.5-large-turbo',\n  'stability-ai/stable-diffusion-3.5-medium',\n  'tstramer/material-diffusion',\n] as const\n\ntype ReplicateModel = (typeof replicateModels)[number] | (string & {})\n\nexport const replicateTools = (\n  { apiKey, model }: { apiKey: string; model?: ReplicateModel },\n  config?: {\n    excludeTools?: ReplicateTools[]\n  }\n): Partial<Record<ReplicateTools, Tool>> => {\n  if (\n    !replicateModels.includes(\n      (model ||\n        'black-forest-labs/flux-1.1-pro') as (typeof replicateModels)[number]\n    )\n  ) {\n    throw new Error('Invalid model')\n  }\n  const tools: Partial<Record<ReplicateTools, Tool>> = {\n    createImage: tool({\n      description: 'Create an image based on the prompt',\n      parameters: z.object({\n        prompt: z.string().describe('The prompt to create an image based on'),\n      }),\n      execute: async ({ prompt }) => {\n        return await createImage(\n          prompt,\n          model ?? 'black-forest-labs/flux-1.1-pro',\n          apiKey\n        )\n      },\n    }),\n  }\n\n  for (const toolName in tools) {\n    if (config?.excludeTools?.includes(toolName as ReplicateTools)) {\n      delete tools[toolName as ReplicateTools]\n    }\n  }\n\n  return tools\n}\n\nasync function createImage(\n  prompt: string,\n  model: ReplicateModel,\n  apiToken: string\n) {\n  const replicate = createReplicate({\n    apiToken,\n  })\n\n  return await generateImage({\n    model: replicate.image(model),\n    prompt,\n  })\n}\n",
        "target": ""
      }
    ],
    "ui": {
      "usage": "import { openai } from '@ai-sdk/openai'\nimport { streamText, convertToCoreMessages } from 'ai'\nimport { replicateTools } from '@/lib/tools/replicate'\n// Allow streaming responses up to 30 seconds\nexport const maxDuration = 30\n\nconst apiKey = process.env.REPLICATE_API_KEY as string\n\nif (!apiKey) {\n  throw new Error('REPLICATE_API_KEY is not set')\n}\n\nexport async function POST(req: Request) {\n  const { messages } = await req.json()\n\n  const result = await streamText({\n    model: openai('gpt-4'),\n    messages: convertToCoreMessages(messages),\n    system: `\n    You are an Image Generation Expert specializing in creating and manipulating images using Replicate's powerful models. Your goal is to help users generate high-quality images based on their prompts and requirements.\n\n    When handling image generation requests, you should:\n\n    1. **Analyze the Request**:\n      - Understand the desired image style and content\n      - Note any specific requirements or constraints\n      - Evaluate prompt clarity and effectiveness\n\n    2. **Available Image Operations**:\n\n      Image Generation:\n      - createImage: Generate an image from a text prompt\n        * Supports various models for different use cases\n        * Handles natural language descriptions\n        * Creates high-quality visual outputs\n\n    3. **Best Practices**:\n\n      Prompt Engineering:\n      - Be specific and descriptive\n      - Include style references when needed\n      - Specify important details\n      - Use clear, unambiguous language\n\n      Model Selection:\n      - Choose based on use case\n      - Consider speed vs. quality tradeoffs\n      - Match model capabilities to requirements\n      - Use specialized models when appropriate\n\n    **Example Interactions**:\n\n    *User*: \"Create a cyberpunk city street at night\"\n\n    *Assistant*: \"I'll help you generate a cyberpunk cityscape:\n\n    1. **Generation Parameters**:\n       Prompt: Cyberpunk night street scene, neon lights reflecting off wet pavement,\n       towering holographic advertisements, dense urban environment, atmospheric fog,\n       detailed architectural elements, cinematic lighting\n\n    Would you like to:\n    - Adjust the lighting atmosphere?\n    - Add specific cyberpunk elements?\n    - Modify the architectural style?\n    - Change the weather conditions?\"\n\n    *User*: \"Generate a professional product photo of a coffee mug\"\n\n    *Assistant*: \"I'll create a professional product shot:\n\n    1. **Generation Parameters**:\n       Prompt: Professional product photography of a modern coffee mug, studio lighting,\n       clean white background, soft shadows, high-end commercial quality, sharp details,\n       minimalist composition\n\n    Would you like to:\n    - Change the background style?\n    - Modify the lighting setup?\n    - Add props or elements?\n    - Adjust the composition?\"\n\n    **Remember**:\n    - Provide clear, detailed prompts\n    - Consider image quality requirements\n    - Handle errors gracefully\n\n    When handling requests, focus on creating high-quality images while providing clear guidance on prompt engineering and model selection.`,\n    maxSteps: 10,\n    tools: {\n      ...replicateTools({\n        apiKey,\n      }),\n    },\n  })\n\n  return result.toDataStreamResponse()\n}\n",
      "title": "Image Generation",
      "tools": [
        {
          "title": "createImage",
          "description": "Create an image based on a prompt"
        }
      ],
      "beta": true
    }
  },
  "telegram": {
    "author": "https://nicolasmontone.com",
    "name": "telegram",
    "type": "registry:lib",
    "description": "Telegram integration tools",
    "dependencies": [
      "zod",
      "ai"
    ],
    "files": [
      {
        "path": "lib/tools/telegram.ts",
        "type": "registry:lib",
        "content": "import { type Tool, tool } from 'ai'\nimport { z } from 'zod'\n\nexport type TelegramTools = 'sendMessage'\n\nexport const telegramTools = (\n  { botToken, chatId }: { botToken: string; chatId: string },\n  config?: { excludeTools?: TelegramTools[] }\n): Partial<Record<TelegramTools, Tool>> => {\n  const telegramUrl = `https://api.telegram.org/bot${botToken}/sendMessage`\n\n  const tools: Partial<Record<TelegramTools, Tool>> = {\n    sendMessage: tool({\n      description: 'Send a message to a telegram chat',\n      parameters: z.object({\n        message: z.string().describe('The message to send'),\n      }),\n      execute: async ({ message }) => {\n        const response = await sendMessage(telegramUrl, chatId, message)\n\n        return response\n      },\n    }),\n  }\n\n  if (config?.excludeTools) {\n    for (const toolName in tools) {\n      if (config.excludeTools.includes(toolName as TelegramTools)) {\n        delete tools[toolName as TelegramTools]\n      }\n    }\n  }\n\n  return tools\n}\n\nasync function sendMessage(\n  telegramUrl: string,\n  chatId: string,\n  message: string\n) {\n  try {\n    const response = await fetch(telegramUrl, {\n      method: 'POST',\n      body: JSON.stringify({\n        chat_id: chatId,\n        text: message,\n      }),\n    })\n\n    if (!response.ok) {\n      return {\n        error: 'Failed to send message',\n      }\n    }\n\n    if (response.status === 200) {\n      return {\n        success: 'Message sent successfully',\n      }\n    }\n  } catch {\n    return {\n      error: 'Failed to send message',\n    }\n  }\n}\n",
        "target": ""
      }
    ],
    "ui": {
      "usage": "import { openai } from '@ai-sdk/openai'\nimport { streamText, convertToCoreMessages } from 'ai'\nimport { telegramTools } from '@/tools/telegram'\n// Allow streaming responses up to 30 seconds\nexport const maxDuration = 30\n\nexport async function POST(req: Request) {\n  const { messages } = await req.json()\n\n  const botToken = process.env.TELEGRAM_BOT_TOKEN\n  const chatId = process.env.TELEGRAM_CHAT_ID\n\n  if (!botToken || !chatId) {\n    return new Response('Missing Telegram credentials', { status: 400 })\n  }\n\n  const result = await streamText({\n    model: openai('gpt-4'),\n    messages: convertToCoreMessages(messages),\n    system: `\n    You are a witty and entertaining comedy bot that specializes in delivering jokes through Telegram! \n    Your mission is to bring laughter and fun to the chat while maintaining good taste and appropriate content.\n    You have a great sense of humor and can deliver various types of jokes:\n\n    - Clever wordplay and puns\n    - Short situational comedy\n    - Light-hearted observations\n    - Classic \"setup-punchline\" jokes\n    - Clean humor suitable for all audiences\n\n    When interacting with users:\n\n    1. **Understand the Joke Request**:\n       - If a specific type of joke is requested (puns, dad jokes, etc.), focus on that\n       - Consider the context and keep it appropriate\n       - Be ready to explain jokes if asked (but remember, explained jokes are like dissected frogs - they help us understand but they don't work anymore!)\n\n    2. **Craft Your Delivery**:\n       - Build up the setup naturally\n       - Time your punchlines well with proper formatting\n       - Use emojis sparingly but effectively 😄\n       - Keep jokes concise and punchy\n\n    3. **Read the Room**:\n       - If a joke doesn't land well, have a funny recovery ready\n       - Be prepared to switch styles if needed\n       - Always keep it light and fun\n\n    **Style Guidelines**:\n\n    - **Joke Content**:\n      - Keep it clean and family-friendly\n      - No offensive or inappropriate content\n      - Avoid controversial topics\n      - Focus on universal humor that most people can relate to\n\n    - **Delivery Format**:\n      - Start with a clear setup\n      - Use proper timing (line breaks when needed)\n      - End with a strong punchline\n      - Add a playful emoji or two when it enhances the joke\n\n    - **Interaction Style**:\n      - Be playful and energetic\n      - Respond to feedback with humor\n      - Stay in character as a fun-loving joke bot\n      - Be ready with follow-up jokes or variations\n\n    Remember to:\n    - Keep the mood light and fun\n    - Read user reactions and adapt\n    - Have backup jokes ready\n    - Stay family-friendly and inclusive\n\n    Don't:\n    - Use inappropriate or offensive humor\n    - Overuse emojis or formatting\n    - Make jokes about sensitive topics\n    - Force humor when the moment isn't right\n\n    Example Joke Delivery:\n    \"Why don't programmers like nature? 🤔\n    It has too many bugs! 🐛😄\"\n    `,\n    maxSteps: 10,\n    tools: {\n      ...telegramTools({ botToken, chatId }),\n    },\n  })\n\n  return result.toDataStreamResponse()\n}\n",
      "title": "Platforms",
      "tools": [
        {
          "title": "sendMessage",
          "description": "Send a message to a Telegram chat"
        }
      ],
      "beta": true
    }
  },
  "exa-ai": {
    "author": "https://nicolasmontone.com",
    "name": "exa-ai",
    "type": "registry:lib",
    "description": "Exa.ai search tools",
    "dependencies": [
      "zod",
      "ai",
      "exa-js"
    ],
    "files": [
      {
        "path": "lib/tools/exa-ai.ts",
        "type": "registry:lib",
        "content": "import { type Tool, tool } from 'ai'\nimport { z } from 'zod'\nimport Exa from 'exa-js'\n\nexport type ExaTools =\n  | 'searchUrls'\n  | 'searchForUrlsContent'\n  | 'searchWikipedia'\n  | 'searchReddit'\n  | 'searchNews'\n\nexport const exaTools = (\n  {\n    apiKey,\n    numResults,\n    includeDomains,\n    excludeDomains,\n    maxCharacters,\n  }: {\n    apiKey: string\n    numResults?: number\n    includeDomains?: string[]\n    excludeDomains?: string[]\n    // used for searchForUrlsContent\n    maxCharacters?: number\n  },\n  {\n    excludeTools,\n  }: {\n    excludeTools?: ExaTools[]\n  }\n): Partial<Record<ExaTools, Tool>> => {\n  const exa = new Exa(apiKey)\n\n  const tools: Partial<Record<ExaTools, Tool>> = {\n    searchUrls: tool({\n      description:\n        'Based on a query returns a list of URLs that are relevant to the query.',\n      parameters: z.object({\n        query: z.string().describe('The query to search for'),\n      }),\n      execute: async ({ query }) => {\n        const results = await performExaSearch(exa, {\n          query,\n          numResults: numResults ?? 5,\n          includeDomains,\n          excludeDomains,\n        })\n        return results\n      },\n    }),\n    searchForUrlsContent: tool({\n      description:\n        'Retrieve the contents of a list of pages given a list of URLs.',\n      parameters: z.object({\n        urls: z\n          .array(z.string().url())\n          .describe('The URLs to retrieve contents for'),\n      }),\n      execute: async ({ urls }) => {\n        const results = await exaGetContents(exa, {\n          urls,\n          maxCharacters: maxCharacters,\n        })\n        return results\n      },\n    }),\n    searchWikipedia: tool({\n      description: 'Fetch the wikipedia page for a given website URL.',\n      parameters: z.object({\n        query: z\n          .string()\n          .describe('The search term or URL to find Wikipedia information for'),\n      }),\n      execute: async ({ query }) => {\n        const result = await exaSearchWikipedia(exa, { query })\n        return result\n      },\n    }),\n    searchReddit: tool({\n      description: 'Fetch the reddit page for a given website URL.',\n      parameters: z.object({\n        query: z\n          .string()\n          .describe('The search term or URL to find Reddit information for'),\n      }),\n      execute: async ({ query }) => {\n        const result = await exaSearchReddit(exa, { query })\n        return result\n      },\n    }),\n    searchNews: tool({\n      description: 'Fetch the latest news for a given query.',\n      parameters: z.object({\n        query: z.string().describe('The query to search for'),\n      }),\n      execute: async ({ query }) => {\n        const result = await exaSearchNews(exa, { query })\n        return result\n      },\n    }),\n  }\n\n  if (excludeTools) {\n    for (const toolName in tools) {\n      if (excludeTools.includes(toolName as ExaTools)) {\n        delete tools[toolName as ExaTools]\n      }\n    }\n  }\n\n  return tools\n}\n\nasync function performExaSearch(\n  exa: Exa,\n  config: {\n    query: string\n    numResults?: number\n    includeDomains?: string[]\n    excludeDomains?: string[]\n  }\n) {\n  const { results } = await exa.search(config.query, {\n    numResults: config.numResults,\n    useAutoprompt: true,\n    includeDomains: config.includeDomains,\n    excludeDomains: config.excludeDomains,\n  })\n  return results\n}\n\nasync function exaGetContents(\n  exa: Exa,\n  config: {\n    urls: string[]\n    numResults?: number\n    includeDomains?: string[]\n    excludeDomains?: string[]\n    maxCharacters?: number\n  }\n) {\n  const { results } = await exa.getContents(config.urls, {\n    useAutoprompt: true,\n    includeDomains: config.includeDomains,\n    excludeDomains: config.excludeDomains,\n    maxCharacters: config.maxCharacters,\n    text: true,\n  })\n  return results\n}\n\nasync function exaSearchWikipedia(exa: Exa, { query }: { query: string }) {\n  const { results } = await exa.searchAndContents(`${query} wikipedia page:`, {\n    type: 'keyword',\n    livecrawl: 'always',\n    includeDomains: ['wikipedia.org'],\n    numResults: 1,\n    text: true,\n    includeText: [query],\n  })\n  return results\n}\n\nasync function exaSearchReddit(exa: Exa, { query }: { query: string }) {\n  const result = await exa.search(query, {\n    type: 'keyword',\n    includeDomains: ['reddit.com'],\n    includeText: [query],\n  })\n  return result.results\n}\n\nasync function exaSearchNews(exa: Exa, { query }: { query: string }) {\n  const result = await exa.searchAndContents(`[${query}] latest news:`, {\n    category: 'news',\n    type: 'keyword',\n    text: true,\n    livecrawl: 'always',\n    includeText: [query],\n    numResults: 10,\n  })\n\n  return result.results\n}\n",
        "target": ""
      }
    ],
    "ui": {
      "usage": "import { openai } from '@ai-sdk/openai'\nimport { streamText, convertToCoreMessages } from 'ai'\nimport { exaTools } from '@/lib/tools/exa-ai'\n// Allow streaming responses up to 30 seconds\nexport const maxDuration = 30\n\nexport async function POST(req: Request) {\n  const { messages } = await req.json()\n\n  const apiKey = process.env.EXA_API_KEY\n\n  if (!apiKey) {\n    return new Response('No Exa API key provided', { status: 400 })\n  }\n\n  const result = await streamText({\n    model: openai('gpt-4o'),\n    messages: convertToCoreMessages(messages),\n    system: `\n    You are a highly skilled Research Assistant with expertise in finding, analyzing, and synthesizing information from various online sources. Your primary goal is to help users discover accurate, relevant, and up-to-date information across the web, including news articles, academic sources, community discussions, and encyclopedic knowledge.\n\n    Your capabilities include:\n\n    1. **Web Research**:\n       - Finding relevant and authoritative web pages\n       - Analyzing content from multiple sources\n       - Verifying information accuracy\n       - Cross-referencing facts\n\n    2. **News Analysis**:\n       - Tracking current events\n       - Finding breaking news\n       - Identifying reliable news sources\n       - Comparing different perspectives\n\n    3. **Academic Research**:\n       - Locating scholarly content\n       - Finding educational resources\n       - Accessing research papers\n       - Understanding technical topics\n\n    4. **Community Insights**:\n       - Discovering public discussions\n       - Finding user experiences\n       - Identifying trending topics\n       - Gathering collective knowledge\n\n    Best Practices:\n\n    1. **Source Quality**:\n       - Prioritize authoritative sources\n       - Verify source credibility\n       - Cross-reference information\n       - Consider publication dates\n\n    2. **Content Analysis**:\n       - Evaluate information relevance\n       - Assess content reliability\n       - Compare multiple viewpoints\n       - Identify key insights\n\n    3. **Research Strategy**:\n       - Use precise search terms\n       - Apply appropriate filters\n       - Consider context\n       - Follow systematic approaches\n\n    Example Research Scenarios:\n\n    *User*: \"What are the latest developments in renewable energy?\"\n\n    *Assistant*: \"I'll help you research renewable energy developments:\n\n    1. **Research Approach**:\n       - Focus on recent developments\n       - Include scientific sources\n       - Consider industry news\n       - Look for policy updates\n\n    I'll search for comprehensive information about:\n    - Latest technological breakthroughs\n    - Industry implementations\n    - Policy changes\n    - Market trends\n    - Research findings\n\n    Would you like to:\n    - Focus on a specific renewable energy type?\n    - Look at particular geographical regions?\n    - Explore economic aspects?\n    - Examine environmental impact studies?\"\n\n    *User*: \"Find expert opinions on machine learning in healthcare\"\n\n    *Assistant*: \"I'll research expert perspectives on healthcare AI:\n\n    1. **Research Focus**:\n       - Medical research papers\n       - Healthcare industry reports\n       - Clinical implementation cases\n       - Expert commentaries\n\n    I'll gather information about:\n    - Clinical applications\n    - Research findings\n    - Implementation challenges\n    - Success stories\n    - Future predictions\n\n    Would you like to:\n    - Focus on specific medical fields?\n    - Look at particular use cases?\n    - Explore regulatory aspects?\n    - Examine specific technologies?\"\n\n    Remember to:\n    - Maintain objectivity\n    - Provide balanced perspectives\n    - Focus on factual information\n    - Consider source credibility\n    - Keep information current\n    - Respect privacy and ethical guidelines\n\n    Your role is to be thorough, accurate, and helpful while providing well-researched information that helps users make informed decisions.`,\n    maxSteps: 22,\n    tools: {\n      ...exaTools(\n        {\n          apiKey,\n          numResults: 3,\n        },\n        {\n          excludeTools: [],\n        }\n      ),\n    },\n  })\n\n  return result.toDataStreamResponse()\n}\n",
      "title": "Search",
      "tools": [
        {
          "title": "searchUrls",
          "description": "Search for URLs based on a query"
        },
        {
          "title": "searchForUrlsContent",
          "description": "Search for content from URLs"
        },
        {
          "title": "searchWikipedia",
          "description": "Search for Wikipedia articles"
        },
        {
          "title": "searchReddit",
          "description": "Search for Reddit discussions"
        },
        {
          "title": "searchNews",
          "description": "Search for news articles"
        }
      ],
      "beta": true
    }
  }
}